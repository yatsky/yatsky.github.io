---
layout: default
title: "Leetcode challenges"
excerpt: Old Leetcode challenges that I did.
---
<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-01-19 Wed 22:22 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode, Data structure and Algorithm</title>
<meta name="author" content="Yi Wang" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="/assets/css/org.css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "5em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "Neo-Euler"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "Neo-Euler"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "left",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<p>Leetcode, Data structure and Algorithm</p></p></p>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Leetcode, Data structure and Algorithm</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org042cb24">1. Introduction</a></li>
<li><a href="#org603524b">2. Problems</a></li>
<li><a href="#org07fc910">3. Data structures</a></li>
<li><a href="#org4a4139c">4. Algorithms</a></li>
<li><a href="#org31c4875">5. Techniques</a></li>
<li><a href="#org16aefec">6. CLRS Notes &amp; Yufei Tao lecture notes</a></li>
<li><a href="#orgf54f621">7. Clock table</a></li>
<li><a href="#orga496f61">8. Appendix</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org042cb24" class="outline-2">
<h2 id="org042cb24"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This is the main file that contains all the problems and their solutions.
Each problem is organised as follows:
</p>
<ul class="org-ul">
<li>Problem number Problem name         :problem<sub>tag</sub>:</li>
<li>Description (Basic info)
<ul class="org-ul">
<li>Examples</li>
</ul></li>
<li>Solution (Tackling process)
<ul class="org-ul">
<li>Understanding the problem</li>
<li>Algorithm (written by me)</li>
<li>Code (written by me)</li>
<li>Complexity
<ul class="org-ul">
<li>Time complexity</li>
<li>Space complexity</li>
</ul></li>
<li>Leetcode solution
<ul class="org-ul">
<li>Time complexity</li>
<li>Space complexity</li>
</ul></li>
</ul></li>
<li>More analysis (Thoughts)
<ul class="org-ul">
<li>General thoughts</li>
<li>Related problems</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org603524b" class="outline-2">
<h2 id="org603524b"><span class="section-number-2">2.</span> Problems</h2>
<div class="outline-text-2" id="text-2">
<p>
Here we start to finish our problems ðŸ˜ˆ.
</p>
</div>
<div id="outline-container-orgdf8071b" class="outline-3">
<h3 id="orgdf8071b"><span class="section-number-3">2.1.</span> Imports for typing</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>imports for typing</label><pre class="src src-python" id="orga02f155"><span class="org-keyword">from</span> typing <span class="org-keyword">import</span> List, Tuple, Set
</pre>
</div>
</div>
</div>
<div id="outline-container-org6d43cd8" class="outline-3">
<h3 id="org6d43cd8"><span class="section-number-3">2.2.</span> <span class="done DONE">DONE</span> 1313 Decompress Run-length encoded list&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-orgdf8ee4d" class="outline-4">
<h4 id="orgdf8ee4d"><span class="section-number-4">2.2.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
We are given a list <code>nums</code> of integers representing a list compressed with run-length encoding.
</p>

<p>
Consider each adjacent pair of elements <code>[freq, val]=[nums[2*i], nums[2*i+1]], i&gt;=0</code>.
For each such pair, there are <code>freq</code> elements with value <code>val</code> concatenated in a sublist.
Concatenate all the sublists from left to right to generate the decompressed list.
</p>

<p>
Return the decompressed list.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>2 &lt;= nums.length &lt;= 100</li>
<li>nums.length % 2 == 0</li>
<li>1 &lt;= nums[i] &lt;= 100</li>
</ol>
</div>
<div id="outline-container-org6733c33" class="outline-5">
<h5 id="org6733c33"><span class="section-number-5">2.2.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-2-1-1">
<pre class="example" id="org863954d">
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].

Input: nums = [1,1,2,3]
Output: [1,3,3]
</pre>
</div>
</div>
</div>

<div id="outline-container-orge50ac40" class="outline-4">
<h4 id="orge50ac40"><span class="section-number-4">2.2.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-2-2">
</div>
<div id="outline-container-org83256cd" class="outline-5">
<h5 id="org83256cd"><span class="section-number-5">2.2.2.1.</span> Understanding the problem</h5>
<div class="outline-text-5" id="text-2-2-2-1">
<p>
Just an array problem.
</p>
</div>
</div>
<div id="outline-container-org68255d8" class="outline-5">
<h5 id="org68255d8"><span class="section-number-5">2.2.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-2-2-2">
<p>
We can use <code>for i in range(len(nums), 2)</code> and create a sublist for all <code>nums[i-1], nums[i]</code>.
Finally we concatenate these sublists.
</p>
</div>
</div>
<div id="outline-container-org0bed4f2" class="outline-5">
<h5 id="org0bed4f2"><span class="section-number-5">2.2.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-2-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>1313 Decompress Run-length encoded list my solution</label><pre class="src src-python" id="orgf83cedd">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">decompress_RLE_list</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; List[<span class="org-builtin">int</span>]:
    <span class="org-variable-name">res</span> = []
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(nums), 2):
        <span class="org-variable-name">sub_lst</span> = [nums[i+1] <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(nums[i])]
        <span class="org-variable-name">res</span> = res+sub_lst
    <span class="org-keyword">return</span> res
<span class="org-keyword">print</span>(decompress_RLE_list([1,1,2,3]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[1, 3, 3]
</pre>
</div>
</div>
</div>

<div id="outline-container-org57bd377" class="outline-5">
<h5 id="org57bd377"><span class="section-number-5">2.2.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-2-2-4">
</div>
<div id="outline-container-org41de36f" class="outline-6">
<h6 id="org41de36f"><span class="section-number-6">2.2.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-2-2-4-1">
<p>
\(O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]\), the summation corresponds to the outer <code>for</code> loop, we simply sum up the time it takes to build each sub list.
</p>
</div>
</div>
<div id="outline-container-orge4bd815" class="outline-6">
<h6 id="orge4bd815"><span class="section-number-6">2.2.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-2-2-4-2">
<p>
\(O(M)\text{, where } M=\sum_{i=0,2,4...}^{len(nums)-2}nums[i]\)
</p>
</div>
</div>
</div>

<div id="outline-container-org986e7be" class="outline-5">
<h5 id="org986e7be"><span class="section-number-5">2.2.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-2-2-5">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>1313 Decompress Run-length encoded list leetcode solution</label><pre class="src src-python" id="org0f6543e">
</pre>
</div>
</div>

<div id="outline-container-orgd21070f" class="outline-6">
<h6 id="orgd21070f"><span class="section-number-6">2.2.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org5df0de7" class="outline-6">
<h6 id="org5df0de7"><span class="section-number-6">2.2.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orga8b91fa" class="outline-4">
<h4 id="orga8b91fa"><span class="section-number-4">2.2.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-2-3">
</div>
<div id="outline-container-orga791c10" class="outline-5">
<h5 id="orga791c10"><span class="section-number-5">2.2.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-2-3-1">
<p>
To concatenate lists in Python.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>concatenate lists</label><pre class="src src-python" id="orgb419c46"><span class="org-variable-name">lst1</span>=[1,2,3]
<span class="org-variable-name">lst2</span>=[3,3,3]
<span class="org-keyword">print</span>(lst1+lst2)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[1, 2, 3, 3, 3, 3]
</pre>
</div>
</div>
</div>
<div id="outline-container-org0127a60" class="outline-5">
<h5 id="org0127a60"><span class="section-number-5">2.2.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-orgf247414" class="outline-3">
<h3 id="orgf247414"><span class="section-number-3">2.3.</span> <span class="done DONE">DONE</span> 1295 Find numbers with even number of digits&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org66725a8" class="outline-4">
<h4 id="org66725a8"><span class="section-number-4">2.3.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Given an array <code>nums</code> of integers, return how many of them contain an <b>even number</b> of digits.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>1 &lt;= nums.length &lt;= 500</li>
<li>1 &lt;= nums[i] &lt;= 10<sup>5</sup></li>
</ol>
</div>
<div id="outline-container-org2efc4ca" class="outline-5">
<h5 id="org2efc4ca"><span class="section-number-5">2.3.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-3-1-1">
<pre class="example" id="org7aa66d2">
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff8451f" class="outline-4">
<h4 id="orgff8451f"><span class="section-number-4">2.3.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-3-2">
</div>
<div id="outline-container-orgc4750f0" class="outline-5">
<h5 id="orgc4750f0"><span class="section-number-5">2.3.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orga91cfb6" class="outline-5">
<h5 id="orga91cfb6"><span class="section-number-5">2.3.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-3-2-2">
<p>
We simply loop the <code>nums</code> and check each number.
We can use this to get the number of all digits of a number: <code>len(str(num))</code>.
</p>
</div>
</div>
<div id="outline-container-org916d023" class="outline-5">
<h5 id="org916d023"><span class="section-number-5">2.3.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-3-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>1295 Find numbers with even number of digits my solution</label><pre class="src src-python" id="org3d52ae9">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">find_numbers</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">res</span> = 0
    <span class="org-keyword">for</span> ele <span class="org-keyword">in</span> nums:
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-builtin">str</span>(ele)) % 2 == 0:
            <span class="org-variable-name">res</span> += 1
    <span class="org-keyword">return</span> res
<span class="org-keyword">print</span>(find_numbers([1,2,3]))
<span class="org-keyword">print</span>(find_numbers([11,2,3]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">0
1
</pre>
</div>
</div>
</div>

<div id="outline-container-org67069bf" class="outline-5">
<h5 id="org67069bf"><span class="section-number-5">2.3.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-3-2-4">
</div>
<div id="outline-container-org757422c" class="outline-6">
<h6 id="org757422c"><span class="section-number-6">2.3.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-3-2-4-1">
<p>
\(O(N)\).
</p>
</div>
</div>
<div id="outline-container-orgfffe567" class="outline-6">
<h6 id="orgfffe567"><span class="section-number-6">2.3.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-3-2-4-2">
<p>
\(O(N)\).
</p>
</div>
</div>
</div>

<div id="outline-container-org4823a8a" class="outline-5">
<h5 id="org4823a8a"><span class="section-number-5">2.3.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-3-2-5">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>1295 Find numbers with even number of digits leetcode solution</label><pre class="src src-python" id="orge4c148c">
</pre>
</div>
</div>

<div id="outline-container-orgfa1d6f4" class="outline-6">
<h6 id="orgfa1d6f4"><span class="section-number-6">2.3.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org7325731" class="outline-6">
<h6 id="org7325731"><span class="section-number-6">2.3.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org97fddb9" class="outline-4">
<h4 id="org97fddb9"><span class="section-number-4">2.3.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-3-3">
</div>
<div id="outline-container-org9be1088" class="outline-5">
<h5 id="org9be1088"><span class="section-number-5">2.3.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-3-3-1">
<p>
Pretty straightforward.
</p>
</div>
</div>
<div id="outline-container-org1dc910d" class="outline-5">
<h5 id="org1dc910d"><span class="section-number-5">2.3.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-org3854950" class="outline-3">
<h3 id="org3854950"><span class="section-number-3">2.4.</span> <span class="done DONE">DONE</span> 1365 How many numbers are smaller than the current number&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-orgc5630b9" class="outline-4">
<h4 id="orgc5630b9"><span class="section-number-4">2.4.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Given the array <code>nums</code>, for each <code>nums[i]</code>, find out how many numbers in the array are smaller than it.
That is, for each <code>nums[i]</code>, you have to count the number of valid <code>j</code>'s, such that <code>j != i and nums[j] &lt; nums[i]&gt;</code>.
</p>

<p>
Return the answer in an array.
</p>

<p>
Constraints:
</p>

<ol class="org-ol">
<li>2 &lt;= nums.length &lt;= 500</li>
<li>0 &lt;= nums[i] &lt;= 100</li>
</ol>
</div>
<div id="outline-container-orgde4cbbc" class="outline-5">
<h5 id="orgde4cbbc"><span class="section-number-5">2.4.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-4-1-1">
<pre class="example" id="org91167fc">
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).

Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
</pre>
</div>
</div>
</div>

<div id="outline-container-org35a020c" class="outline-4">
<h4 id="org35a020c"><span class="section-number-4">2.4.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-4-2">
</div>
<div id="outline-container-org3568c3b" class="outline-5">
<h5 id="org3568c3b"><span class="section-number-5">2.4.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org81fe9b1" class="outline-5">
<h5 id="org81fe9b1"><span class="section-number-5">2.4.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-4-2-2">
<p>
We first sort <code>nums</code>, and get <code>sorted_nums</code>.
We loop through <code>sorted_nums</code>, and get <code>smaller_count</code> mapping in the form of <code>{num: smaller_count}</code>.
We then loop <code>nums</code> and get <code>smaller_count</code> of each <code>num</code>, store them in <code>res</code>.
</p>
</div>
</div>
<div id="outline-container-org93b1355" class="outline-5">
<h5 id="org93b1355"><span class="section-number-5">2.4.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-4-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>1365 How many numbers are smaller than the current number my solution</label><pre class="src src-python" id="org459899f">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">smaller_numbers_than_current</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; List[<span class="org-builtin">int</span>]:
    <span class="org-keyword">import</span> math
    <span class="org-variable-name">sorted_nums</span> = <span class="org-builtin">sorted</span>(nums)

    <span class="org-variable-name">smaller_counts</span> = {}
    <span class="org-keyword">for</span> i, e <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(sorted_nums):
        <span class="org-variable-name">smaller_counts</span>[e] = <span class="org-builtin">min</span>(smaller_counts.get(e, math.inf), i)

    <span class="org-variable-name">res</span> = []
    <span class="org-keyword">for</span> num <span class="org-keyword">in</span> nums:
        res.append(smaller_counts[num])

    <span class="org-keyword">return</span> res
<span class="org-keyword">print</span>(smaller_numbers_than_current([2,2,3,4,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[1, 1, 3, 4, 0]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf2f2658" class="outline-5">
<h5 id="orgf2f2658"><span class="section-number-5">2.4.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-4-2-4">
</div>
<div id="outline-container-orgf6b7fa0" class="outline-6">
<h6 id="orgf6b7fa0"><span class="section-number-6">2.4.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-4-2-4-1">
<p>
\(O(N\log{N})\).
</p>
</div>
</div>
<div id="outline-container-org087ebee" class="outline-6">
<h6 id="org087ebee"><span class="section-number-6">2.4.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-4-2-4-2">
<p>
\(O(N)\).
</p>
</div>
</div>
</div>

<div id="outline-container-org42b131c" class="outline-5">
<h5 id="org42b131c"><span class="section-number-5">2.4.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-4-2-5">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>1365 How many numbers are smaller than the current number leetcode solution</label><pre class="src src-python" id="org3292690">
</pre>
</div>
</div>

<div id="outline-container-org65f0cae" class="outline-6">
<h6 id="org65f0cae"><span class="section-number-6">2.4.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org27f3dd1" class="outline-6">
<h6 id="org27f3dd1"><span class="section-number-6">2.4.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org7061066" class="outline-4">
<h4 id="org7061066"><span class="section-number-4">2.4.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-4-3">
</div>
<div id="outline-container-org9a91f5a" class="outline-5">
<h5 id="org9a91f5a"><span class="section-number-5">2.4.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-4-3-1">
<p>
The best time complexity we can do is \(O(N\log N)\).
</p>
</div>
</div>
<div id="outline-container-orgf25fc50" class="outline-5">
<h5 id="orgf25fc50"><span class="section-number-5">2.4.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-org25b1c30" class="outline-3">
<h3 id="org25b1c30"><span class="section-number-3">2.5.</span> <span class="done DONE">DONE</span> 1409 Queries on a permutation with key&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-orgef3fc05" class="outline-4">
<h4 id="orgef3fc05"><span class="section-number-4">2.5.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
Given the array <code>queries</code> of positive integers between <code>1</code> and <code>m</code>, you have to process all <code>queries[i]</code> (from <code>i=0</code> to <code>i=queries.length-1</code>) according to the following rules:
</p>
<ol class="org-ol">
<li>in the beginning, you have the permutation <code>P=[1,2,3,...,m]</code>.</li>
<li>For the current <code>i</code>, find the position of <code>queries[i]</code> in the permutation <code>P</code> (indexing from 0) and then move this at the begining of the permutation <code>P</code>. Notice that the position of <code>queries[i]</code> in <code>P</code> is the result for <code>queries[i]</code>.</li>
</ol>

<p>
Return an array containing the result for the given <code>queries</code>.
</p>

<p>
Constraints:
</p>

<ol class="org-ol">
<li>1 &lt;= m &lt;= 10<sup>3</sup></li>
<li>1 &lt;= queries.length &lt;= m</li>
<li>1 &lt;= queries[i] &lt;= m</li>
</ol>
</div>
<div id="outline-container-orga9c2567" class="outline-5">
<h5 id="orga9c2567"><span class="section-number-5">2.5.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-5-1-1">
<pre class="example" id="org88a16a4">
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
</pre>
</div>
</div>
</div>

<div id="outline-container-org4cc8f8c" class="outline-4">
<h4 id="org4cc8f8c"><span class="section-number-4">2.5.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-5-2">
</div>
<div id="outline-container-orgebf84e0" class="outline-5">
<h5 id="orgebf84e0"><span class="section-number-5">2.5.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orga05d4ea" class="outline-5">
<h5 id="orga05d4ea"><span class="section-number-5">2.5.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-5-2-2">
<p>
We can use brute force.
We loop through queries <code>for i, e in enumerate(queries)</code>, then have an inner loop <code>for j, e_p in enumerate(p_copy)</code>, when <code>e_p==e</code>, we do <code>P.pop(j)</code>, <code>P.insert(0, e_p)</code>, and <code>res.append(j)</code>.
</p>
</div>
</div>
<div id="outline-container-org6dafc31" class="outline-5">
<h5 id="org6dafc31"><span class="section-number-5">2.5.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-5-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>1409 Queries on a permutation with key my solution</label><pre class="src src-python" id="org0cb9e9a">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">process_queries</span>(queries: List[<span class="org-builtin">int</span>], m: <span class="org-builtin">int</span>) -&gt; List[<span class="org-builtin">int</span>]:
    <span class="org-variable-name">res</span> = []

    <span class="org-variable-name">p</span> = <span class="org-builtin">list</span>(<span class="org-builtin">range</span>(1, m+1))
    <span class="org-variable-name">p_copy</span> = p.copy()
    <span class="org-keyword">for</span> i, e <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(queries):
        <span class="org-variable-name">p_copy</span> = p.copy()
        <span class="org-keyword">for</span> j, e_p <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(p_copy):
            <span class="org-keyword">if</span> e_p == e:
                p.pop(j)
                p.insert(0, e_p)
                res.append(j)

    <span class="org-keyword">return</span> res

<span class="org-keyword">print</span>(process_queries([3,1,2,1],5))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[2, 1, 2, 1]
</pre>
</div>
</div>
</div>

<div id="outline-container-org955692b" class="outline-5">
<h5 id="org955692b"><span class="section-number-5">2.5.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-5-2-4">
</div>
<div id="outline-container-org54ae271" class="outline-6">
<h6 id="org54ae271"><span class="section-number-6">2.5.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-5-2-4-1">
<p>
\(O(N\times M)\text{ , where }N=len(queries), M=m\).
</p>
</div>
</div>
<div id="outline-container-org2e0910c" class="outline-6">
<h6 id="org2e0910c"><span class="section-number-6">2.5.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-5-2-4-2">
<p>
\(O(M)\).
</p>
</div>
</div>
</div>
<div id="outline-container-orgb03e66c" class="outline-5">
<h5 id="orgb03e66c"><span class="section-number-5">2.5.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-5-2-5">
<p>
Not available.
</p>

<p>
Here is one interesting solution from the discussion forum.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>1409 Queries on a permutation with key discussion solution</label><pre class="src src-python" id="org3ce47f9">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">process_queries</span>(queries: List[<span class="org-builtin">int</span>], m: <span class="org-builtin">int</span>) -&gt; List[<span class="org-builtin">int</span>]:
    <span class="org-comment-delimiter"># </span><span class="org-comment">the original code uses</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">def process(arr, idx), which is quite confusing</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">as we are trying to find the idx of an element</span>
    <span class="org-keyword">def</span> <span class="org-function-name">process</span>(arr, elem):
        <span class="org-variable-name">ans</span> = arr.index(elem)
        arr.insert(0, arr.pop(ans))
        <span class="org-keyword">return</span> ans

    <span class="org-variable-name">m</span> = [x <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, m+1)]
    <span class="org-keyword">return</span> [process(m, i) <span class="org-keyword">for</span> i <span class="org-keyword">in</span> queries]

<span class="org-keyword">print</span>(process_queries([3,1,2,1],5))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[2, 1, 2, 1]
</pre>
</div>
</div>

<div id="outline-container-org9cc86d4" class="outline-6">
<h6 id="org9cc86d4"><span class="section-number-6">2.5.2.5.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-5-2-5-1">
<p>
\(O(N\times M)\text{ , where }N=len(queries), M=m\).
</p>
</div>
</div>

<div id="outline-container-orgb77085b" class="outline-6">
<h6 id="orgb77085b"><span class="section-number-6">2.5.2.5.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-5-2-5-2">
<p>
\(O(M)\).
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org170a1fc" class="outline-4">
<h4 id="org170a1fc"><span class="section-number-4">2.5.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-5-3">
</div>
<div id="outline-container-org54a0126" class="outline-5">
<h5 id="org54a0126"><span class="section-number-5">2.5.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-orgf631e6a" class="outline-5">
<h5 id="orgf631e6a"><span class="section-number-5">2.5.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org340efaf" class="outline-3">
<h3 id="org340efaf"><span class="section-number-3">2.6.</span> 1329 Sort the matrix diagonally</h3>
<div class="outline-text-3" id="text-2-6">
<p>
This is based on an incorrect understanding of the problem description.
See <a href="#org1a4c570">2.7</a> for a correct understanding and solution.
</p>
</div>
<div id="outline-container-org405b6dc" class="outline-4">
<h4 id="org405b6dc"><span class="section-number-4">2.6.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Given a <code>m*n</code> matrix <code>mat</code> of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>m == mat.length</li>
<li>n == mat[i].length</li>
<li>1 &lt;= m, n &lt;= 100</li>
<li>1 &lt;= mat[i][j] &lt;= 100</li>
</ol>
</div>
<div id="outline-container-org9f22b15" class="outline-5">
<h5 id="org9f22b15"><span class="section-number-5">2.6.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-6-1-1">
<pre class="example" id="orge2c380d">
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2729ad" class="outline-4">
<h4 id="orgd2729ad"><span class="section-number-4">2.6.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-6-2">
</div>
<div id="outline-container-org7b5912b" class="outline-5">
<h5 id="org7b5912b"><span class="section-number-5">2.6.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org06455a1" class="outline-5">
<h5 id="org06455a1"><span class="section-number-5">2.6.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-6-2-2">
<p>
We first concatenate all lists in the matrix, then sort it to get <code>sorted_lst</code>.
<del>Then we re-construct the resulting matrix and return it.</del>
Then we create a new empty <code>m*n</code> matrix <code>res</code> filled with <code>None</code>.
We then loop through <code>sorted_lst</code>, and fill the first row of <code>res</code>, then the first column, then second row, second column&#x2026;
Recall that a 2D array can be mapped to a 1D array.
</p>
</div>
</div>
<div id="outline-container-orgad4362e" class="outline-5">
<h5 id="orgad4362e"><span class="section-number-5">2.6.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-6-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>1329 Sort the matrix diagonally my solution</label><pre class="src src-python" id="orgf19e8ac">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">diagonal_sort</span>(mat: List[List[<span class="org-builtin">int</span>]]) -&gt; List[List[<span class="org-builtin">int</span>]]:
    <span class="org-keyword">import</span> itertools

    <span class="org-variable-name">m</span> = <span class="org-builtin">len</span>(mat)
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(mat[0])
    <span class="org-variable-name">res</span> = [[<span class="org-constant">None</span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n)] <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m)]
    <span class="org-variable-name">sorted_lst</span> = <span class="org-builtin">sorted</span>(itertools.chain(*mat))

    <span class="org-variable-name">cur_col</span> = 0
    <span class="org-variable-name">cur_row</span> = 0

    <span class="org-variable-name">idx</span> = 0
    <span class="org-keyword">while</span> cur_col &lt; n <span class="org-keyword">or</span> cur_row &lt; m:
        <span class="org-keyword">if</span> cur_col &lt; n:
            <span class="org-keyword">for</span> moving_col <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cur_col, n):
                res[cur_row][moving_col] = sorted_lst[idx]
                <span class="org-variable-name">idx</span> += 1

            <span class="org-comment-delimiter"># </span><span class="org-comment">cur_row+1 so that it does not overwrite</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">the first data in the column</span>
        <span class="org-keyword">if</span> cur_row &lt; m:
            <span class="org-keyword">for</span> moving_row <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cur_row+1, m):
                res[moving_row][cur_col] = sorted_lst[idx]
                <span class="org-variable-name">idx</span> += 1

        <span class="org-variable-name">cur_col</span> = <span class="org-builtin">min</span>(n-1, cur_col+1)
        <span class="org-variable-name">cur_row</span> = <span class="org-builtin">min</span>(m-1, cur_row+1)
        <span class="org-keyword">if</span> cur_col == n-1 <span class="org-keyword">and</span> cur_row == m-1 <span class="org-keyword">and</span> res[m-1][n-1] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-keyword">break</span>
    <span class="org-keyword">return</span> res
<span class="org-comment-delimiter">#</span><span class="org-comment">print(diagonal_sort([[2,1],[3,2],[3,2]]))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">print(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">print(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))</span>
<span class="org-keyword">print</span>(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[[1, 4, 5, 7, 8, 11], [11, 22, 23, 25, 25, 27], [14, 28, 36, 44, 45, 50], [15, 31, 52, 58, 66, 68], [17, 33, 55, 69, 75, 84]]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd97bab" class="outline-5">
<h5 id="orgdd97bab"><span class="section-number-5">2.6.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-6-2-4">
</div>
<div id="outline-container-orgb1bc72b" class="outline-6">
<h6 id="orgb1bc72b"><span class="section-number-6">2.6.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org1d869f8" class="outline-6">
<h6 id="org1d869f8"><span class="section-number-6">2.6.2.4.2.</span> Space complexity:</h6>
</div>
</div>

<div id="outline-container-org2a797c5" class="outline-5">
<h5 id="org2a797c5"><span class="section-number-5">2.6.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-6-2-5">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span>1329 Sort the matrix diagonally leetcode solution</label><pre class="src src-python" id="orgc15bac8">
</pre>
</div>
</div>

<div id="outline-container-orgd02a1f0" class="outline-6">
<h6 id="orgd02a1f0"><span class="section-number-6">2.6.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org06bedae" class="outline-6">
<h6 id="org06bedae"><span class="section-number-6">2.6.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org41d8a40" class="outline-4">
<h4 id="org41d8a40"><span class="section-number-4">2.6.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-6-3">
</div>
<div id="outline-container-org4bfd052" class="outline-5">
<h5 id="org4bfd052"><span class="section-number-5">2.6.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-org7d805a7" class="outline-5">
<h5 id="org7d805a7"><span class="section-number-5">2.6.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org1a4c570" class="outline-3">
<h3 id="org1a4c570"><span class="section-number-3">2.7.</span> <span class="done DONE">DONE</span> 1329 Sort the matrix diagonally 2&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-7">
</div>
<div id="outline-container-org1077355" class="outline-4">
<h4 id="org1077355"><span class="section-number-4">2.7.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
Given a <code>m*n</code> matrix <code>mat</code> of integers, sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>m == mat.length</li>
<li>n == mat[i].length</li>
<li>1 &lt;= m, n &lt;= 100</li>
<li>1 &lt;= mat[i][j] &lt;= 100</li>
</ol>
</div>

<div id="outline-container-orgcf78cf0" class="outline-5">
<h5 id="orgcf78cf0"><span class="section-number-5">2.7.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-7-1-1">
<pre class="example" id="orgf38b658">
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org7903a9a" class="outline-4">
<h4 id="org7903a9a"><span class="section-number-4">2.7.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-7-2">
</div>
<div id="outline-container-org96b4a4f" class="outline-5">
<h5 id="org96b4a4f"><span class="section-number-5">2.7.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orgedb90b4" class="outline-5">
<h5 id="orgedb90b4"><span class="section-number-5">2.7.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-7-2-2">
<p>
With the existing <code>mat</code>, we want to sort each existing diagonal so that they are ascend from top-left to bottom right. We do not want to sort the entire matrix.
</p>

<p>
We need to first get all the starting cell of each diagonal list <code>(x, y)</code>.
With it, we can easily get the diagonal list by adding 1 to both <code>x</code> and <code>y</code>.
We then sort each diagonal list and put them back to the <code>mat</code>.
</p>
</div>
</div>
<div id="outline-container-org32a65f9" class="outline-5">
<h5 id="org32a65f9"><span class="section-number-5">2.7.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-7-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span>1329 Sort the matrix diagonally 2 my solution</label><pre class="src src-python" id="orgd47e22e">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">diagonal_sort</span>(mat: List[List[<span class="org-builtin">int</span>]]) -&gt; List[List[<span class="org-builtin">int</span>]]:
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(mat)
    <span class="org-variable-name">m</span> = <span class="org-builtin">len</span>(mat[0])

    <span class="org-keyword">def</span> <span class="org-function-name">sort_list</span>(head: Tuple[<span class="org-builtin">int</span>]) -&gt; <span class="org-constant">None</span>:
        <span class="org-variable-name">res</span> = []
        <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span> = head
        <span class="org-keyword">while</span> x &lt; n <span class="org-keyword">and</span> y &lt; m:
            res.append(mat[x][y])
            <span class="org-variable-name">x</span>+=1
            <span class="org-variable-name">y</span>+=1

        res.sort()
        <span class="org-variable-name">res</span> = <span class="org-builtin">iter</span>(res)
        <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span> = head
        <span class="org-keyword">while</span> x &lt; n <span class="org-keyword">and</span> y &lt; m:
            mat[x][y] = <span class="org-builtin">next</span>(res)
            <span class="org-variable-name">x</span>+=1
            <span class="org-variable-name">y</span>+=1

    <span class="org-variable-name">diagonal_heads</span> = [(x, y) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n) <span class="org-keyword">for</span> y <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m)]

    <span class="org-keyword">for</span> head <span class="org-keyword">in</span> diagonal_heads:
        sort_list(head)
        
    <span class="org-keyword">return</span> mat
<span class="org-keyword">print</span>(diagonal_sort([[4,2,3],[1,3,4]]))
<span class="org-keyword">print</span>(diagonal_sort([[2,1],[3,2],[3,2]]))
<span class="org-keyword">print</span>(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
<span class="org-keyword">print</span>(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
<span class="org-keyword">print</span>(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[[3, 2, 3], [1, 4, 4]]
[[2, 1], [2, 2], [3, 3]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[1, 1, 1, 1], [1, 2, 2, 2], [1, 2, 3, 3]]
[[5, 17, 4, 1, 52, 7], [11, 11, 25, 45, 8, 69], [14, 23, 25, 44, 58, 15], [22, 27, 31, 36, 50, 66], [84, 28, 75, 33, 55, 68]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org66fc631" class="outline-5">
<h5 id="org66fc631"><span class="section-number-5">2.7.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-7-2-4">
</div>
<div id="outline-container-orgc53c775" class="outline-6">
<h6 id="orgc53c775"><span class="section-number-6">2.7.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-7-2-4-1">
<p>
This is a bit hard to analyse, but the basic idea is to add up all the time taken to sort all diagonal lists. The total number of such lists is \(m+n-1\).
By observation, we can get that the number of the longest diagonal list(s) in the matrix is \(|n-m+1|\).
The number of remaining lists would be \(m+n-1-|n-m+1|\), which gives us either \(2\times (m-1)\) or \(2\times (n-1)\).
</p>

<p>
Therefore, our formula to calculate the total time required by the algorithm is as follows:
</p>


<p>
\(O(2\times (\sum_{i=1}^{\min(n,m)-1} i\log i)+|n-m+1|\times \min(m,n)\times \log{\min(m,n)})\).
</p>
</div>
</div>
<div id="outline-container-org66f5c7a" class="outline-6">
<h6 id="org66f5c7a"><span class="section-number-6">2.7.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-7-2-4-2">
<p>
\(O(\sqrt{m\times n})\).
</p>
</div>
</div>
</div>
<div id="outline-container-orge9904b2" class="outline-5">
<h5 id="orge9904b2"><span class="section-number-5">2.7.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-7-2-5">
<p>
Not available.
</p>

<p>
Interesting one <a href="https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489846/Several-Python-solutions">here</a>.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span>1329 Sort the matrix diagonally 2 leetcode solution</label><pre class="src src-python" id="org50a513d"><span class="org-keyword">def</span> <span class="org-function-name">diagonal_sort</span>(mat):
    <span class="org-variable-name">m</span>, <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(mat), <span class="org-builtin">len</span>(mat[0])

    <span class="org-keyword">def</span> <span class="org-function-name">sort</span>(i, j):
        <span class="org-variable-name">ij</span> = <span class="org-builtin">zip</span>(<span class="org-builtin">range</span>(i, m), <span class="org-builtin">range</span>(j, n))
        <span class="org-variable-name">vals</span> = <span class="org-builtin">iter</span>(<span class="org-builtin">sorted</span>(mat[i][j] <span class="org-keyword">for</span> i, j <span class="org-keyword">in</span> ij))
        <span class="org-keyword">for</span> i, j <span class="org-keyword">in</span> ij:
            mat[i][j] = <span class="org-builtin">next</span>(vals)

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m): sort(i, 0)
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m): sort(0, j)

    <span class="org-keyword">return</span> mat

<span class="org-keyword">print</span>(diagonal_sort([[4,2,3],[1,3,4]]))
<span class="org-keyword">print</span>(diagonal_sort([[2,1],[3,2],[3,2]]))
<span class="org-keyword">print</span>(diagonal_sort([[1,2,1],[3,2,4],[7,7,4]]))
<span class="org-keyword">print</span>(diagonal_sort([[3,3,1,1],[2,2,1,2],[1,1,1,2]]))
<span class="org-keyword">print</span>(diagonal_sort(
    [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[[4, 2, 3], [1, 3, 4]]
[[2, 1], [3, 2], [3, 2]]
[[1, 2, 1], [3, 2, 4], [7, 7, 4]]
[[3, 3, 1, 1], [2, 2, 1, 2], [1, 1, 1, 2]]
[[11, 25, 66, 1, 69, 7], [23, 55, 17, 45, 15, 52], [75, 31, 36, 44, 58, 8], [22, 27, 33, 25, 68, 4], [84, 28, 14, 11, 5, 50]]
</pre>
</div>
</div>

<div id="outline-container-orgb44f770" class="outline-6">
<h6 id="orgb44f770"><span class="section-number-6">2.7.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-orgbdeb319" class="outline-6">
<h6 id="orgbdeb319"><span class="section-number-6">2.7.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgb0d7d3b" class="outline-4">
<h4 id="orgb0d7d3b"><span class="section-number-4">2.7.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-7-3">
</div>
<div id="outline-container-orgc2d3a70" class="outline-5">
<h5 id="orgc2d3a70"><span class="section-number-5">2.7.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-orgb883f77" class="outline-5">
<h5 id="orgb883f77"><span class="section-number-5">2.7.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org35b2818" class="outline-3">
<h3 id="org35b2818"><span class="section-number-3">2.8.</span> <span class="done DONE">DONE</span> 1395 Count number of teams&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-8">
</div>
<div id="outline-container-orgedbd5f2" class="outline-4">
<h4 id="orgedbd5f2"><span class="section-number-4">2.8.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
There are <code>n</code> soldiers standing in a line. Each soldier is assigned a <b>unique</b> <code>rating</code> value.
</p>

<p>
You have to form a team of 3 soldiers amongst them under the following rules:
</p>
<ol class="org-ol">
<li>Choose 3 soldiers with index(i, j, k) with rating <code>(rating[i], rating[j], rating[k])</code>.</li>
<li>A team is valid if: <code>(rating[i]&lt;rating[j]&lt;rating[k])</code> or <code>rating[i]&gt;rating[j]&gt;rating[k]</code>, where <code>0&lt;=i&lt;j&lt;k&lt;n</code>.</li>
</ol>

<p>
Soldiers can be part of multiple teams.
</p>

<p>
Return the number of teams you can form given the conditions.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>n == rating.length</li>
<li>1 &lt;= n &lt;= 200</li>
<li>1 &lt;= rating[i] &lt;= 10<sup>5</sup></li>
</ol>
</div>
<div id="outline-container-org1d7206c" class="outline-5">
<h5 id="org1d7206c"><span class="section-number-5">2.8.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-8-1-1">
<pre class="example" id="org8814d20">
Input: rating = [2,5,3,4,1]
Output: 3
Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). 

Input: rating = [2,1,3]
Output: 0
Explanation: We can't form any team given the conditions.

Input: rating = [1,2,3,4]
Output: 4
</pre>
</div>
</div>
</div>

<div id="outline-container-org7aa75d7" class="outline-4">
<h4 id="org7aa75d7"><span class="section-number-4">2.8.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-8-2">
</div>
<div id="outline-container-org4585e14" class="outline-5">
<h5 id="org4585e14"><span class="section-number-5">2.8.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org032b83b" class="outline-5">
<h5 id="org032b83b"><span class="section-number-5">2.8.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-8-2-2">
<p>
We return <code>False</code> for all <code>n&lt;3</code>.
</p>

<p>
This is a combination problem. We need to try all combinations of the list.
</p>
</div>
</div>
<div id="outline-container-org1cb7045" class="outline-5">
<h5 id="org1cb7045"><span class="section-number-5">2.8.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-8-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span>1395 Count number of teams my solution</label><pre class="src src-python" id="orgc404ef3">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;
<span class="org-keyword">def</span> <span class="org-function-name">num_teams</span>(rating: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(rating) &lt; 3:
        <span class="org-keyword">return</span> 0

    <span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> combinations

    <span class="org-variable-name">count</span> = 0
    <span class="org-keyword">for</span> comb <span class="org-keyword">in</span> combinations(rating, 3):
        <span class="org-keyword">if</span> comb[0] &lt; comb[1] &lt; comb[2] <span class="org-keyword">or</span> comb[0]&gt;comb[1]&gt;comb[2]:
            <span class="org-variable-name">count</span> += 1


    <span class="org-keyword">return</span> count
<span class="org-keyword">print</span>(num_teams([2,5,3,4,1]))
<span class="org-keyword">print</span>(num_teams([2,1,3]))
<span class="org-keyword">print</span>(num_teams([1,2,3,4]))
<span class="org-keyword">print</span>(num_teams([0,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">3
0
4
0
</pre>
</div>
</div>
</div>

<div id="outline-container-org10fbe5a" class="outline-5">
<h5 id="org10fbe5a"><span class="section-number-5">2.8.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-8-2-4">
</div>
<div id="outline-container-orgfffee87" class="outline-6">
<h6 id="orgfffee87"><span class="section-number-6">2.8.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-8-2-4-1">
<p>
\(O(C_{n}^{3})\), i.e. \(O(n^3)\).
</p>
</div>
</div>
<div id="outline-container-org58ec251" class="outline-6">
<h6 id="org58ec251"><span class="section-number-6">2.8.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-8-2-4-2">
<p>
\(O(1)\).
</p>
</div>
</div>
</div>
<div id="outline-container-1395 Count number of teams Leetcode" class="outline-5">
<h5 id="1395 Count number of teams Leetcode"><span class="section-number-5">2.8.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-1395 Count number of teams Leetcode">
<p>
Not available.
</p>

<p>
This following is adapted from <a href="https://leetcode.com/problems/count-number-of-teams/discuss/554817/Java-O(N2)-Time-O(N)-Space-(Best-Solution)">this Java solution</a>.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span>1395 Count number of teams efficient solution</label><pre class="src src-python" id="orgdb91360">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;
<span class="org-keyword">def</span> <span class="org-function-name">num_teams</span>(rating: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">ans</span> = 0
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(rating)

    <span class="org-variable-name">biggerLeft</span>, <span class="org-variable-name">biggerRight</span> = {}, {}

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n-1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(i+1, n):
            <span class="org-keyword">if</span> rating[i] &lt; rating[j]:
                <span class="org-variable-name">biggerRight</span>[i] = biggerRight.get(i, 0) + 1
            <span class="org-keyword">elif</span> rating[i] &gt; rating[j]:
                <span class="org-variable-name">biggerLeft</span>[j] = biggerLeft.get(j, 0) + 1

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n-1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(i+1, n):
            <span class="org-keyword">if</span> rating[i] &lt; rating[j]:
                <span class="org-variable-name">ans</span> += biggerRight.get(j, 0)
            <span class="org-keyword">elif</span> rating[i] &gt; rating[j]:
                <span class="org-variable-name">ans</span> += biggerLeft.get(i, 0)
    <span class="org-keyword">return</span> ans
<span class="org-keyword">print</span>(num_teams([2,5,3,4,1]))
<span class="org-keyword">print</span>(num_teams([2,1,3]))
<span class="org-keyword">print</span>(num_teams([1,2,3,4]))
<span class="org-keyword">print</span>(num_teams([0,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">3
0
4
0
</pre>
</div>
</div>


<div id="outline-container-orgaaf13b6" class="outline-6">
<h6 id="orgaaf13b6"><span class="section-number-6">2.8.2.5.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-8-2-5-1">
<p>
\(O(N^2)\).
</p>
</div>
</div>
<div id="outline-container-orgcaff3c8" class="outline-6">
<h6 id="orgcaff3c8"><span class="section-number-6">2.8.2.5.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-8-2-5-2">
<p>
\(O(N)\).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org35f14ff" class="outline-4">
<h4 id="org35f14ff"><span class="section-number-4">2.8.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-8-3">
</div>
<div id="outline-container-org5959964" class="outline-5">
<h5 id="org5959964"><span class="section-number-5">2.8.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-8-3-1">
<p>
Brute-forcing this problem should be prohibited as this is medium level problem.
We should try to use some better algorithms to solve it.
</p>

<p>
<a href="#1395 Count number of teams Leetcode">2.8.2.5</a> is a neat solution to the problem and a specia case of a general solution, which is provided here.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span>1395 Count number of teams general solution</label><pre class="src src-python" id="orgf05d9fe">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">calc_combinations</span>(n: <span class="org-builtin">int</span>, k: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    n: total number of items</span>
<span class="org-doc">    k: number of items to be drawn</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">calculated</span> = {}
    <span class="org-keyword">def</span> <span class="org-function-name">factorial</span>(n: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-keyword">if</span> n == 0 <span class="org-keyword">or</span> n == 1:
            <span class="org-keyword">return</span> 1
        <span class="org-keyword">if</span> n <span class="org-keyword">not</span> <span class="org-keyword">in</span> calculated.keys():
            <span class="org-variable-name">calculated</span>[n] = n * factorial(n-1)
        <span class="org-keyword">return</span> calculated[n]

    <span class="org-keyword">if</span> n &lt; k :
        <span class="org-keyword">return</span> 0
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(factorial(n)/factorial(k)/factorial(n-k))

<span class="org-keyword">def</span> <span class="org-function-name">num_teams</span>(rating: List[<span class="org-builtin">int</span>], team_len: <span class="org-builtin">int</span> = 3) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">ans</span> = 0
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(rating)

    <span class="org-variable-name">biggerLeft</span>, <span class="org-variable-name">biggerRight</span> = {}, {}

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n-1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(i+1, n):
            <span class="org-keyword">if</span> rating[i] &lt; rating[j]:
                <span class="org-variable-name">biggerRight</span>[i] = biggerRight.get(i, 0) + 1
            <span class="org-keyword">elif</span> rating[i] &gt; rating[j]:
                <span class="org-variable-name">biggerLeft</span>[j] = biggerLeft.get(j, 0) + 1

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n-1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(i+1, n):
            <span class="org-keyword">if</span> rating[i] &lt; rating[j]:
                <span class="org-comment-delimiter"># </span><span class="org-comment">team_len-2 gives the remaining numbers that need to be drawn</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">from biggerRight.get(j, 0) given rating[i] and rating[j]</span>
                <span class="org-variable-name">ans</span> += calc_combinations(biggerRight.get(j, 0), team_len-2)
            <span class="org-keyword">elif</span> rating[i] &gt; rating[j]:
                <span class="org-variable-name">ans</span> += calc_combinations(biggerLeft.get(i, 0), team_len-2)
    <span class="org-keyword">return</span> ans
<span class="org-keyword">print</span>(num_teams([2,7,8,9,10], 4))
<span class="org-keyword">print</span>(num_teams([2,1,3]))
<span class="org-keyword">print</span>(num_teams([1,2,3,4]))
<span class="org-keyword">print</span>(num_teams([0,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">5
0
4
0
</pre>
</div>
</div>
</div>

<div id="outline-container-org1071082" class="outline-5">
<h5 id="org1071082"><span class="section-number-5">2.8.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org89427de" class="outline-3">
<h3 id="org89427de"><span class="section-number-3">2.9.</span> <span class="done DONE">DONE</span> 442 Find all duplicates in an array&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-9">
</div>
<div id="outline-container-orgedb946e" class="outline-4">
<h4 id="orgedb946e"><span class="section-number-4">2.9.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
Given an array of integers, \(1\le a[i] \le n, n=\text{size of array}\), some elements appear <b>twice</b> and others appear <b>once</b>.
</p>

<p>
Find all the elements that appear <b>twice</b> in this array.
</p>

<p>
Constraints:
Do it without extra space and in \(O(n)\) runtime.
</p>
</div>

<div id="outline-container-org5ce6f26" class="outline-5">
<h5 id="org5ce6f26"><span class="section-number-5">2.9.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-9-1-1">
<pre class="example" id="org541855f">
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
</pre>
</div>
</div>
</div>

<div id="outline-container-orge667daa" class="outline-4">
<h4 id="orge667daa"><span class="section-number-4">2.9.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-9-2">
</div>
<div id="outline-container-orgb7d5da7" class="outline-5">
<h5 id="orgb7d5da7"><span class="section-number-5">2.9.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orgdc33324" class="outline-5">
<h5 id="orgdc33324"><span class="section-number-5">2.9.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-9-2-2">
<p>
See <a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/92390/Python-O(n)-time-O(1)-space">Discussion</a>.
</p>

<p>
\(\because\):
Given the condition \(\max(arr)\le \text{len}(arr)\), we know that each number element in the array should be able to be mapped to an index of the array.
</p>

<p>
We also know that, a number in the array either occurs just once or twice.
</p>

<p>
\(\therefore\):
when iterating the array, we can mark the number at index <code>i</code> negative when we first encounter it. If we never see it again, then we can safely ignore it (once). The second time we see it and it's negative, we add it to the final result (twice). 
</p>
</div>
</div>

<div id="outline-container-org1f6a0a2" class="outline-5">
<h5 id="org1f6a0a2"><span class="section-number-5">2.9.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-9-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span>442 Find all duplicates in an array my solution</label><pre class="src src-python" id="org8a4a48a">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">find_duplicates</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; List[<span class="org-builtin">int</span>]:
    <span class="org-variable-name">res</span> = []
    <span class="org-keyword">for</span> n <span class="org-keyword">in</span> nums:
        <span class="org-keyword">if</span> nums[<span class="org-builtin">abs</span>(n)-1] &lt; 0:
            res.append(<span class="org-builtin">abs</span>(n))
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">nums</span>[<span class="org-builtin">abs</span>(n)-1] *= -1
    <span class="org-keyword">return</span> res

<span class="org-keyword">print</span>(find_duplicates([1,2,3,3]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[3]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf8a9c9" class="outline-5">
<h5 id="orgbf8a9c9"><span class="section-number-5">2.9.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-9-2-4">
</div>
<div id="outline-container-org9a6da70" class="outline-6">
<h6 id="org9a6da70"><span class="section-number-6">2.9.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-9-2-4-1">
<p>
\(O(N)\).
</p>
</div>
</div>
<div id="outline-container-org79b1f22" class="outline-6">
<h6 id="org79b1f22"><span class="section-number-6">2.9.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-9-2-4-2">
<p>
\(O(1)\), excluding the returning result <code>res</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org4a2f0e9" class="outline-5">
<h5 id="org4a2f0e9"><span class="section-number-5">2.9.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-9-2-5">
<p>
Not available.
</p>

<p>
Most interesting idea has been provided in the previous section.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span>442 Find all duplicates in an array leetcode solution</label><pre class="src src-python" id="orgbef37fa">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>
</div>

<div id="outline-container-org5595b24" class="outline-6">
<h6 id="org5595b24"><span class="section-number-6">2.9.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org431f3af" class="outline-6">
<h6 id="org431f3af"><span class="section-number-6">2.9.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org16faf3c" class="outline-4">
<h4 id="org16faf3c"><span class="section-number-4">2.9.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-9-3">
</div>
<div id="outline-container-org4b5ec8f" class="outline-5">
<h5 id="org4b5ec8f"><span class="section-number-5">2.9.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-org8d8a3f2" class="outline-5">
<h5 id="org8d8a3f2"><span class="section-number-5">2.9.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org1322686" class="outline-3">
<h3 id="org1322686"><span class="section-number-3">2.10.</span> <span class="done DONE">DONE</span> 78 Subsets&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-10">
</div>
<div id="outline-container-orgf6727a5" class="outline-4">
<h4 id="orgf6727a5"><span class="section-number-4">2.10.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-10-1">
<p>
Given a set of <b>distinct</b> integers, <code>nums</code>, return all possible subsets (the power set).
</p>

<p>
Constraints:
The solution set must not contain duplicate subsets.
</p>
</div>
<div id="outline-container-orgaba0ad1" class="outline-5">
<h5 id="orgaba0ad1"><span class="section-number-5">2.10.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-10-1-1">
<pre class="example" id="org5874165">
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</pre>
</div>
</div>
</div>

<div id="outline-container-org892b8b1" class="outline-4">
<h4 id="org892b8b1"><span class="section-number-4">2.10.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-10-2">
</div>
<div id="outline-container-org659e695" class="outline-5">
<h5 id="org659e695"><span class="section-number-5">2.10.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orgdaf4f86" class="outline-5">
<h5 id="orgdaf4f86"><span class="section-number-5">2.10.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-10-2-2">
<p>
We can use Python's <code>itertools.combinations</code>.
</p>
</div>
</div>
<div id="outline-container-orga7af6f5" class="outline-5">
<h5 id="orga7af6f5"><span class="section-number-5">2.10.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-10-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span>78 Subsets my solution</label><pre class="src src-python" id="org4f39e99">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">subsets</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; List[List[<span class="org-builtin">int</span>]]:
    <span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> combinations, chain

    <span class="org-variable-name">res</span> = [combinations(nums, i) <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, <span class="org-builtin">len</span>(nums) + 1)]
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(<span class="org-builtin">map</span>(<span class="org-builtin">list</span>, chain(*res))) + [[]]
<span class="org-keyword">print</span>(subsets([1,2,3]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3], []]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf316925" class="outline-5">
<h5 id="orgf316925"><span class="section-number-5">2.10.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-10-2-4">
</div>
<div id="outline-container-orgf5d0ffd" class="outline-6">
<h6 id="orgf5d0ffd"><span class="section-number-6">2.10.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-10-2-4-1">
<p>
\(O(\frac{N!}{(N-K)!K!})\)
</p>
</div>
</div>
<div id="outline-container-org24572dc" class="outline-6">
<h6 id="org24572dc"><span class="section-number-6">2.10.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-10-2-4-2">
<p>
\(O(\frac{N!}{(N-K)!K!})\)
</p>
</div>
</div>
</div>

<div id="outline-container-78 Subsets Leetcode Solution" class="outline-5">
<h5 id="78 Subsets Leetcode Solution"><span class="section-number-5">2.10.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-78 Subsets Leetcode Solution">
<p>
Bitmask solution.
The idea is that we map each subset to a bitmask of length n, where 1 on the <i>ith</i> position in the bitmask meas the presence of <code>nums[i]</code> in the subset, and 0 means its absence.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span>78 Subsets leetcode solution</label><pre class="src src-python" id="org02476e1">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">subsets</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; List[List[<span class="org-builtin">int</span>]]:
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(nums)
    <span class="org-variable-name">output</span> = []

    <span class="org-comment-delimiter"># </span><span class="org-comment">nth_bit = "1000"</span>
    <span class="org-variable-name">nth_bit</span> = 1&lt;&lt;n
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2**n):
        <span class="org-comment-delimiter"># </span><span class="org-comment">generate bit mask, from 0..00 to 1..11</span>
        <span class="org-variable-name">bitmask</span> = <span class="org-builtin">bin</span>(i | nth_bit)[3:]
        <span class="org-comment-delimiter"># </span><span class="org-comment">append subset corresponding to that bit mask</span>
        output.append([nums[j] <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n) <span class="org-keyword">if</span> bitmask[j] == <span class="org-string">'1'</span>])

    <span class="org-keyword">return</span> output
<span class="org-keyword">print</span>(subsets([1,2,3]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">0b1000
000
0b1001
001
0b1010
010
0b1011
011
0b1100
100
0b1101
101
0b1110
110
0b1111
111
[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
</pre>
</div>
</div>

<div id="outline-container-orgef717c5" class="outline-6">
<h6 id="orgef717c5"><span class="section-number-6">2.10.2.5.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-10-2-5-1">
<p>
\(O(\frac{N!}{(N-K)!K!})\)
</p>
</div>
</div>
<div id="outline-container-org867173f" class="outline-6">
<h6 id="org867173f"><span class="section-number-6">2.10.2.5.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-10-2-5-2">
<p>
\(O(\frac{N!}{(N-K)!K!})\)
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org4afd1cc" class="outline-4">
<h4 id="org4afd1cc"><span class="section-number-4">2.10.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-10-3">
</div>
<div id="outline-container-org031ac6e" class="outline-5">
<h5 id="org031ac6e"><span class="section-number-5">2.10.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-10-3-1">
<p>
See <a href="#org5f70f26">5.1.1</a>
</p>
</div>
</div>
<div id="outline-container-orgccdb525" class="outline-5">
<h5 id="orgccdb525"><span class="section-number-5">2.10.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-orgeac9210" class="outline-3">
<h3 id="orgeac9210"><span class="section-number-3">2.11.</span> <span class="done DONE">DONE</span> 48 Rotate image&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-11">
</div>
<div id="outline-container-org7bce862" class="outline-4">
<h4 id="org7bce862"><span class="section-number-4">2.11.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-11-1">
<p>
You are given an <code>n*n</code> 2D matrix representing an image.
</p>

<p>
Rotate the image 90 degrees (clockwise).
</p>

<p>
Constraints:
</p>

<p>
You have to rotate the image in-place.
</p>
</div>
<div id="outline-container-org91b0926" class="outline-5">
<h5 id="org91b0926"><span class="section-number-5">2.11.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-11-1-1">
<pre class="example" id="org29d29cf">
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</pre>
</div>
</div>
</div>

<div id="outline-container-org6f4c100" class="outline-4">
<h4 id="org6f4c100"><span class="section-number-4">2.11.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-11-2">
</div>
<div id="outline-container-orgbe5dd4b" class="outline-5">
<h5 id="orgbe5dd4b"><span class="section-number-5">2.11.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orgc10523e" class="outline-5">
<h5 id="orgc10523e"><span class="section-number-5">2.11.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-11-2-2">
<p>
Given the coordinate of a point <code>(row, col)</code> in the matrix <code>mat</code> (<code>n*n</code>), to rotate a matrix clockwise by 90 degrees is to do the following:
<code>map(lambda (row, col): (col, n-1-row), mat)</code>.
</p>
</div>
</div>
<div id="outline-container-48 Rotate image my solution" class="outline-5">
<h5 id="48 Rotate image my solution"><span class="section-number-5">2.11.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-48 Rotate image my solution">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span>48 Rotate image my solution</label><pre class="src src-python" id="org587c0d9">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">rotate</span>(matrix: List[List[<span class="org-builtin">int</span>]]) -&gt; <span class="org-constant">None</span>:
    <span class="org-keyword">import</span> math
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(matrix)
    <span class="org-keyword">def</span> <span class="org-function-name">rotate_square</span>(mat: List[List[<span class="org-builtin">int</span>]], coor: Tuple[<span class="org-builtin">int</span>]) -&gt; <span class="org-constant">None</span>:
        <span class="org-variable-name">row</span>, <span class="org-variable-name">col</span> = coor
        <span class="org-variable-name">target_val</span> = mat[col][n-1-row]
        mat[col][n-1-row] = mat[row][col]

        <span class="org-variable-name">row</span>, <span class="org-variable-name">col</span> = col, n-1-row
        <span class="org-variable-name">temp</span> = mat[col][n-1-row]
        mat[col][n-1-row] = target_val

        <span class="org-variable-name">row</span>, <span class="org-variable-name">col</span> = col, n-1-row
        <span class="org-variable-name">target_val</span> = mat[col][n-1-row]
        mat[col][n-1-row] = temp

        <span class="org-variable-name">row</span>, <span class="org-variable-name">col</span> = col, n-1-row
        mat[col][n-1-row] = target_val

    <span class="org-keyword">for</span> cur_row <span class="org-keyword">in</span> <span class="org-builtin">range</span>(math.ceil(n/2)):
        <span class="org-keyword">for</span> cur_col <span class="org-keyword">in</span> <span class="org-builtin">range</span>(cur_row, n-cur_row-1):
            rotate_square(matrix, (cur_row, cur_col))

    <span class="org-keyword">print</span>(matrix)

rotate([[1,2],[3,4]])
rotate([[1,2,3],[4,5,6],[7,8,9]])
rotate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[[3, 1], [4, 2]]
[[7, 4, 1], [8, 5, 2], [9, 6, 3]]
[[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org5bb157f" class="outline-5">
<h5 id="org5bb157f"><span class="section-number-5">2.11.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-11-2-4">
</div>
<div id="outline-container-org08b7fc0" class="outline-6">
<h6 id="org08b7fc0"><span class="section-number-6">2.11.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-11-2-4-1">
<p>
\(O(N^2)\).
</p>
</div>
</div>
<div id="outline-container-org8dd117a" class="outline-6">
<h6 id="org8dd117a"><span class="section-number-6">2.11.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-11-2-4-2">
<p>
\(O(1)\)
</p>
</div>
</div>
</div>
<div id="outline-container-org8961b62" class="outline-5">
<h5 id="org8961b62"><span class="section-number-5">2.11.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-11-2-5">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span>48 Rotate image leetcode solution</label><pre class="src src-python" id="orge3ca249">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>
</div>

<div id="outline-container-orgf6ff2b7" class="outline-6">
<h6 id="orgf6ff2b7"><span class="section-number-6">2.11.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org331b38f" class="outline-6">
<h6 id="org331b38f"><span class="section-number-6">2.11.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgb239d06" class="outline-4">
<h4 id="orgb239d06"><span class="section-number-4">2.11.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-11-3">
</div>
<div id="outline-container-orgb8c51c0" class="outline-5">
<h5 id="orgb8c51c0"><span class="section-number-5">2.11.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-11-3-1">
<p>
My solution is very cumbersome, especially the <code>rotate_square()</code> function.
As shown in the Leetcode discussion forum, it is easier to flip the matrix instead of actually rotating it because flip the matrix only involves <b>swapping</b> two values. Whereas my <code>rotate_square()</code> involves introducing two temporary variables to finish a rotation.
</p>

<p>
The other way to mitigate the problem in my solution is to use the following code, which does the rotation of four elements at once.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span>48 rotate image sample</label><pre class="src src-python" id="orgac48993">matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j], matrix[n - 1 - j][i] 
= matrix[n - 1 - j][i], matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j]
</pre>
</div>
</div>
</div>
<div id="outline-container-org560267a" class="outline-5">
<h5 id="org560267a"><span class="section-number-5">2.11.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-orgb17c2e0" class="outline-3">
<h3 id="orgb17c2e0"><span class="section-number-3">2.12.</span> <span class="done DONE">DONE</span> 72 Edit distance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dp">dp</span>&#xa0;<span class="hard">hard</span></span></h3>
<div class="outline-text-3" id="text-2-12">
</div>
<div id="outline-container-org38ae86c" class="outline-4">
<h4 id="org38ae86c"><span class="section-number-4">2.12.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-12-1">
<p>
Given two words, <code>word1</code> and <code>word2</code>, find the minimum number of operations required to convert <code>word1</code> to <code>word2</code>.
</p>

<p>
You have the following 3 operations permitted on a word:
</p>
<ol class="org-ol">
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>

<p>
Constraints:
</p>
</div>

<div id="outline-container-org337c313" class="outline-5">
<h5 id="org337c313"><span class="section-number-5">2.12.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-12-1-1">
<pre class="example" id="org85ad6f7">
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -&gt; inention (remove 't')
inention -&gt; enention (replace 'i' with 'e')
enention -&gt; exention (replace 'n' with 'x')
exention -&gt; exection (replace 'n' with 'c')
exection -&gt; execution (insert 'u')
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc380529" class="outline-4">
<h4 id="orgc380529"><span class="section-number-4">2.12.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-12-2">
</div>
<div id="outline-container-orgd02b919" class="outline-5">
<h5 id="orgd02b919"><span class="section-number-5">2.12.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orgf7dfd6a" class="outline-5">
<h5 id="orgf7dfd6a"><span class="section-number-5">2.12.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-12-2-2">
<p>
This is a typical dynamic programming problem.
</p>
</div>
</div>
<div id="outline-container-orgfc9344c" class="outline-5">
<h5 id="orgfc9344c"><span class="section-number-5">2.12.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-12-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span>72 Edit distance my solution</label><pre class="src src-python" id="orge18eda6">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">min_distance</span>(word1: <span class="org-builtin">str</span>, word2: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">m</span> = <span class="org-builtin">len</span>(word1)
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(word2)

    <span class="org-keyword">if</span> m == 0:
        <span class="org-keyword">return</span> n
    <span class="org-keyword">if</span> n == 0:
        <span class="org-keyword">return</span> m

    <span class="org-variable-name">tbl</span> = [[0 <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m+1)]

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m+1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1):
            <span class="org-keyword">if</span> i == 0:
                tbl[i][j] = j
            <span class="org-keyword">elif</span> j==0:
                tbl[i][j] = i
            <span class="org-keyword">elif</span> word1[i-1] == word2[j-1]:
                tbl[i][j] = tbl[i-1][j-1]
            <span class="org-keyword">else</span>:
                tbl[i][j] = 1 + <span class="org-builtin">min</span>(
                    tbl[i-1][j],
                    tbl[i][j-1],
                    tbl[i-1][j-1]
                )

    <span class="org-keyword">return</span> tbl[m][n]
</pre>
</div>
</div>
</div>

<div id="outline-container-org6e58a13" class="outline-5">
<h5 id="org6e58a13"><span class="section-number-5">2.12.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-12-2-4">
</div>
<div id="outline-container-org2829f4c" class="outline-6">
<h6 id="org2829f4c"><span class="section-number-6">2.12.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-12-2-4-1">
<p>
\(O(MN)\)
</p>
</div>
</div>
<div id="outline-container-org1ad8268" class="outline-6">
<h6 id="org1ad8268"><span class="section-number-6">2.12.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-12-2-4-2">
<p>
\(O(MN)\)
</p>
</div>
</div>
</div>

<div id="outline-container-org9ce3a35" class="outline-5">
<h5 id="org9ce3a35"><span class="section-number-5">2.12.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-12-2-5">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span>72 Edit distance leetcode solution</label><pre class="src src-python" id="org8558d83">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>
</div>

<div id="outline-container-org24fdd7e" class="outline-6">
<h6 id="org24fdd7e"><span class="section-number-6">2.12.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org2d0e0ea" class="outline-6">
<h6 id="org2d0e0ea"><span class="section-number-6">2.12.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org8f1cc69" class="outline-4">
<h4 id="org8f1cc69"><span class="section-number-4">2.12.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-12-3">
</div>
<div id="outline-container-orga854b0d" class="outline-5">
<h5 id="orga854b0d"><span class="section-number-5">2.12.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-12-3-1">
<p>
See <a href="#orgc89f2c8">4.2.1</a>.
</p>
</div>
</div>
<div id="outline-container-orgd6b2dda" class="outline-5">
<h5 id="orgd6b2dda"><span class="section-number-5">2.12.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-orgc8968e2" class="outline-3">
<h3 id="orgc8968e2"><span class="section-number-3">2.13.</span> <span class="done DONE">DONE</span> 121 Best time to buy and sell stock&#xa0;&#xa0;&#xa0;<span class="tag"><span class="array">array</span>&#xa0;<span class="hard">hard</span>&#xa0;<span class="dp">dp</span></span></h3>
<div class="outline-text-3" id="text-2-13">
</div>
<div id="outline-container-org9095132" class="outline-4">
<h4 id="org9095132"><span class="section-number-4">2.13.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-13-1">
<p>
Say you have an array for which the <code>ith</code> element is the price of a given stock on day <code>i</code>.
</p>

<p>
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
</p>

<p>
Constraints:
You cannot sell a stock before you buy one.
</p>
</div>
<div id="outline-container-org9798708" class="outline-5">
<h5 id="org9798708"><span class="section-number-5">2.13.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-13-1-1">
<pre class="example" id="org34baea9">
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
             
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</pre>
</div>
</div>
</div>

<div id="outline-container-orga33c987" class="outline-4">
<h4 id="orga33c987"><span class="section-number-4">2.13.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-13-2">
</div>
<div id="outline-container-org76bb66a" class="outline-5">
<h5 id="org76bb66a"><span class="section-number-5">2.13.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org4995b0e" class="outline-5">
<h5 id="org4995b0e"><span class="section-number-5">2.13.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-13-2-2">
<p>
<del>We build up a table of all possible combinations from the <code>prices</code> list.</del>
<del>Half of the table is not necessary.</del>
We first sort the list <code>prices</code> and convert it to a ordered map that <code>{price: day}</code>.
Then we start from the lowest price <code>p_low</code>, and check it against the highest price <code>p_hi</code>, if <code>price[p_hi]&gt;price[p_low]</code>, we already find one candidate of the result and move <code>p_low</code> to the right, else, we move <code>p_hi</code> to the left.
</p>
</div>
</div>
<div id="outline-container-org3403454" class="outline-5">
<h5 id="org3403454"><span class="section-number-5">2.13.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-13-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span>121 Best time to buy and sell stock my solution</label><pre class="src src-python" id="org94bc125">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">max_profit</span>(prices: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:

    <span class="org-variable-name">max_p</span> = 0

    <span class="org-variable-name">price_map</span> = {}
    <span class="org-keyword">for</span> i, p <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(prices):
        <span class="org-keyword">if</span> p <span class="org-keyword">not</span> <span class="org-keyword">in</span> price_map.keys():
            <span class="org-variable-name">price_map</span>[p] = i

    prices.sort()

    <span class="org-keyword">for</span> p_buy <span class="org-keyword">in</span> prices:
        <span class="org-variable-name">d_buy</span> = price_map[p_buy]
        <span class="org-keyword">for</span> p_sell <span class="org-keyword">in</span> <span class="org-builtin">reversed</span>(prices):
            <span class="org-variable-name">d_sell</span> = price_map[p_sell]
            <span class="org-keyword">if</span> p_buy&lt;p_sell <span class="org-keyword">and</span> d_buy &lt; d_sell:
                <span class="org-variable-name">max_p</span> = <span class="org-builtin">max</span>(max_p, p_sell-p_buy)
                <span class="org-keyword">break</span>

    <span class="org-keyword">return</span> max_p
<span class="org-keyword">print</span>(max_profit([7,1,5,3,6,4]))
<span class="org-keyword">print</span>(max_profit([7,6,5]))
<span class="org-keyword">print</span>(max_profit([1,4,1,4,3,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">5
0
3
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd9b3af0" class="outline-5">
<h5 id="orgd9b3af0"><span class="section-number-5">2.13.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-13-2-4">
</div>
<div id="outline-container-org29b210c" class="outline-6">
<h6 id="org29b210c"><span class="section-number-6">2.13.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org62bbe39" class="outline-6">
<h6 id="org62bbe39"><span class="section-number-6">2.13.2.4.2.</span> Space complexity:</h6>
</div>
</div>

<div id="outline-container-orgbf17b04" class="outline-5">
<h5 id="orgbf17b04"><span class="section-number-5">2.13.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-13-2-5">
<p>
If we plot the numbers in the array on a graph, we will have a line graph.
</p>

<p>
The points of interest are the peaks and valleys in the given graph. We need to find the highest peak, following the lowest valley. We can maintain two variables - <code>minprice</code> and <code>maxprofit</code> corresponding to the lowest valley and maximum profit (max difference between selling price and <code>minprice</code>) obtained so far respectively.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span>121 Best time to buy and sell stock leetcode solution</label><pre class="src src-python" id="orgdcf1006">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">max_profit</span>(prices: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-variable-name">minprice</span> = inf
    <span class="org-variable-name">maxprofit</span> = 0

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(prices)):
        <span class="org-keyword">if</span> prices[i] &lt; minprice:
            <span class="org-variable-name">minprice</span> = prices[i]
        <span class="org-keyword">elif</span> prices[i] - minprice &gt; maxprofit:
            <span class="org-variable-name">maxprofit</span> = prices[i] - minprice

    <span class="org-keyword">return</span> maxprofit
<span class="org-keyword">print</span>(max_profit([1,2,3,4,5]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">4
</pre>
</div>
</div>

<div id="outline-container-org747fad4" class="outline-6">
<h6 id="org747fad4"><span class="section-number-6">2.13.2.5.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-13-2-5-1">
<p>
\(O(N)\)
</p>
</div>
</div>

<div id="outline-container-orgec34a84" class="outline-6">
<h6 id="orgec34a84"><span class="section-number-6">2.13.2.5.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-13-2-5-2">
<p>
\(O(1)\)
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7e1fb38" class="outline-4">
<h4 id="org7e1fb38"><span class="section-number-4">2.13.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-13-3">
</div>
<div id="outline-container-org31c2f46" class="outline-5">
<h5 id="org31c2f46"><span class="section-number-5">2.13.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-13-3-1">
<p>
Initially I was trying to use dynamic programming to solve this problem, as is indicated by the problem's DP tag, then it was very hard to start because the problem does not seem to have an obvious subproblems that will be solved multiple times.
</p>

<p>
The solutions provided by Leetcode did not use DP either, but then other people suggested that it <i>can</i> be categorised as a very <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/">simple DP problem</a> and tabulation can be used to solve it.
</p>

<blockquote>
<p>
The prerequisites for using DP are:
</p>
<ol class="org-ol">
<li>optimal substructure</li>
<li>overlaping sub-problems</li>
</ol>

<p>
In this problem, sub-problems <code>f[i]</code> is defined as "the minimum stock price from day 0 to day <code>i</code>", which is dependant on <code>f[i-1]</code> and <code>prices[i]</code>, whichever is lower.
The overlapping sub-problem here is very obvious - there's no need to calculate <code>f[i]</code> by comparing stock prices from day 0 to day <code>i-1</code>, which is the brute force solution, but just reuse the pre-calculated result <code>f[i-1]</code>.
</p>

<p>
<code>maxprofit</code> variable may or may not be in the DP table, as it can be viewed as a simple global max, and we can simply get it by <code>maxprofit=max(maxprofit, prices[i-1]-dp[i-1][0])</code>.
</p>
</blockquote>

<p>
Also people mentioned that this is similar to <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">Kadane's Algorithm for Maximum Subarray Sum</a>.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span>121 Best time to buy and sell stock dp solution</label><pre class="src src-python" id="org2fae78a"><span class="org-keyword">def</span> <span class="org-function-name">max_profit</span>(prices) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(prices)
    <span class="org-variable-name">dp</span> = [[0, 0] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)]

    <span class="org-comment-delimiter"># </span><span class="org-comment">starting price</span>
    dp[0][0] = inf

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n+1):
        dp[i][0] = <span class="org-builtin">min</span>(dp[i-1][0], prices[i-1])
        dp[i][1] = <span class="org-builtin">max</span>(dp[i-1][1], prices[i-1]-dp[i-1][0])

    <span class="org-keyword">return</span> dp[n][1]
<span class="org-keyword">print</span>(max_profit([1,2,3,4,5]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">4
</pre>
</div>
</div>
</div>
<div id="outline-container-org28ca958" class="outline-5">
<h5 id="org28ca958"><span class="section-number-5">2.13.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-13-3-2">
<p>
<a href="#org1fc7989">2.14</a>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1fc7989" class="outline-3">
<h3 id="org1fc7989"><span class="section-number-3">2.14.</span> <span class="done DONE">DONE</span> 53 Maximum subarray&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dp">dp</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-14">
</div>
<div id="outline-container-orgb92f1de" class="outline-4">
<h4 id="orgb92f1de"><span class="section-number-4">2.14.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-14-1">
<p>
Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
</p>

<p>
Constraints:
Use \(O(N)\) time.
</p>
</div>
<div id="outline-container-org9565cb5" class="outline-5">
<h5 id="org9565cb5"><span class="section-number-5">2.14.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-14-1-1">
<pre class="example" id="org4b6d44a">
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
</pre>
</div>
</div>
</div>

<div id="outline-container-org339e359" class="outline-4">
<h4 id="org339e359"><span class="section-number-4">2.14.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-14-2">
</div>
<div id="outline-container-org391d590" class="outline-5">
<h5 id="org391d590"><span class="section-number-5">2.14.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org4aeba5f" class="outline-5">
<h5 id="org4aeba5f"><span class="section-number-5">2.14.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-14-2-2">
<p>
Use dynamic programming.
The sub-problem is "the maximum sum of previous arrays".
</p>
</div>
</div>
<div id="outline-container-org0ef5cc0" class="outline-5">
<h5 id="org0ef5cc0"><span class="section-number-5">2.14.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-14-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span>53 Maximum subarray my solution</label><pre class="src src-python" id="orgc05ff89">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">max_subarray</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(nums)
    <span class="org-keyword">if</span> n == 1:
        <span class="org-keyword">return</span> nums[0]

    <span class="org-comment-delimiter"># </span><span class="org-comment">this is actualy not needed</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">see General thoughts</span>
    <span class="org-variable-name">dp</span> = [0 <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)]
    <span class="org-variable-name">dp</span>[0] = -inf

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n+1):
        <span class="org-variable-name">dp</span>[i] =<span class="org-builtin">max</span>(nums[i-1], nums[i-1] + dp[i-1])

    <span class="org-keyword">return</span> <span class="org-builtin">max</span>(dp)
<span class="org-keyword">print</span>(max_subarray([-2,1,-3,4,-1,2,1,-5,4]))
<span class="org-keyword">print</span>(max_subarray([-2,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">6
1
</pre>
</div>
</div>
</div>

<div id="outline-container-org0570118" class="outline-5">
<h5 id="org0570118"><span class="section-number-5">2.14.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-14-2-4">
</div>
<div id="outline-container-org7562a58" class="outline-6">
<h6 id="org7562a58"><span class="section-number-6">2.14.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-14-2-4-1">
<p>
\(O(N)\).
</p>
</div>
</div>
<div id="outline-container-org3953bc3" class="outline-6">
<h6 id="org3953bc3"><span class="section-number-6">2.14.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-14-2-4-2">
<p>
\(O(N)\) but \(O(1)\) can be achieved by removing the <code>dp</code> array.
</p>
</div>
</div>
</div>

<div id="outline-container-orgee989c4" class="outline-5">
<h5 id="orgee989c4"><span class="section-number-5">2.14.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-14-2-5">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span>53 Maximum subarray leetcode solution</label><pre class="src src-python" id="org5e089af">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>
</div>

<div id="outline-container-orge9471cd" class="outline-6">
<h6 id="orge9471cd"><span class="section-number-6">2.14.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org546dcef" class="outline-6">
<h6 id="org546dcef"><span class="section-number-6">2.14.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgc790f00" class="outline-4">
<h4 id="orgc790f00"><span class="section-number-4">2.14.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-14-3">
</div>
<div id="outline-container-org89a05bd" class="outline-5">
<h5 id="org89a05bd"><span class="section-number-5">2.14.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-14-3-1">
<p>
<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">Wikipedia</a> introduces the history of this problem as "a simplified model for <i>maximum likelihood</i> estimate of patterns in digitized images".
</p>

<p>
In this problem, \(O(1)\) space can be achieved.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span>53 Maximum subarray my solution O(1) space</label><pre class="src src-python" id="org315cd12">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">max_subarray</span>(nums: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(nums)
    <span class="org-keyword">if</span> n == 1:
        <span class="org-keyword">return</span> nums[0]

    <span class="org-variable-name">cur_sum</span> = -inf
    <span class="org-variable-name">best_sum</span> = cur_sum

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n+1):
        <span class="org-variable-name">cur_sum</span> =<span class="org-builtin">max</span>(nums[i-1], nums[i-1] + cur_sum)
        <span class="org-variable-name">best_sum</span> = <span class="org-builtin">max</span>(best_sum, cur_sum)

    <span class="org-keyword">return</span> best_sum
<span class="org-keyword">print</span>(max_subarray([-2,1,-3,4,-1,2,1,-5,4]))
<span class="org-comment-delimiter">#</span><span class="org-comment">print(max_subarray([-2,1]))</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">6
</pre>
</div>
</div>
</div>

<div id="outline-container-org85f618f" class="outline-5">
<h5 id="org85f618f"><span class="section-number-5">2.14.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-14-3-2">
<p>
<a href="#orgc8968e2">2.13</a>
The <code>minprice</code> in <a href="#orgc8968e2">2.13</a> is the <code>cur_sum</code> in this question, and <code>maxprofit</code> in <a href="#orgc8968e2">2.13</a> is the <code>best_sum</code> in this question.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org25c4cd7" class="outline-3">
<h3 id="org25c4cd7"><span class="section-number-3">2.15.</span> <span class="done DONE">DONE</span> 70 Climbming stairs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dp">dp</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-15">
</div>
<div id="outline-container-orgd47ebff" class="outline-4">
<h4 id="orgd47ebff"><span class="section-number-4">2.15.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-15-1">
<p>
You are climbing a stair case. It takes <code>n</code> steps to reach to the top.
</p>

<p>
Each time you can either climbe 1 or 2 steps. In how many distinct ways you can climb to the top?
</p>

<p>
Constraints:
<code>n</code> will be positive integer.
</p>
</div>
<div id="outline-container-orge1977a4" class="outline-5">
<h5 id="orge1977a4"><span class="section-number-5">2.15.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-15-1-1">
<pre class="example" id="orgaf3a578">
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</pre>
</div>
</div>
</div>

<div id="outline-container-org13d4315" class="outline-4">
<h4 id="org13d4315"><span class="section-number-4">2.15.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-15-2">
</div>
<div id="outline-container-org34a8580" class="outline-5">
<h5 id="org34a8580"><span class="section-number-5">2.15.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org7474e49" class="outline-5">
<h5 id="org7474e49"><span class="section-number-5">2.15.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-15-2-2">
<p>
This is basically a Fibonacci series.
<del>We need to do a "top-down" calculation of the ways we can take.</del>
<del>Starting from the top (<code>n</code>), there are two ways to go back (one step or two steps), and we are at <code>n-1</code>.</del>
<del>By the same token, when we are at <code>n-1</code>, for the two different stairs we are at, there are two stairs we can take for each of them. We first calculate one of them, and store the number of ways to go down in a map. This map can be later used for calculating another possibility at <code>n-1</code>.</del>
</p>

<p>
<del>We continue this until we reach the bottom.</del>
</p>

<p>
<del>We then do addition: <code>ans[n] = ans[n-1]+ans[n-2]</code>.</del>
The code is written in "bottom-up" format. Somehow for me it is easier to think this way. Previously mentioned algorithm still works but is hard for me to implement as I am not sure how to solve the recursive part when we use a map to simplify calculation.
</p>
</div>
</div>
<div id="outline-container-orgaae8b44" class="outline-5">
<h5 id="orgaae8b44"><span class="section-number-5">2.15.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-15-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span>70 Climbming stairs my solution</label><pre class="src src-python" id="org37c95f0">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">climb_stairs</span>(n: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">dp</span> = [0 <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)]

    dp[0], <span class="org-variable-name">dp</span>[1] = 1, 1
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2, n+1):
        <span class="org-variable-name">dp</span>[i] = dp[i-1] + dp[i-2]
    <span class="org-keyword">return</span> dp[n]
<span class="org-keyword">print</span>(climb_stairs(4))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">5
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e418f1" class="outline-5">
<h5 id="org3e418f1"><span class="section-number-5">2.15.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-15-2-4">
</div>
<div id="outline-container-org0a45bc1" class="outline-6">
<h6 id="org0a45bc1"><span class="section-number-6">2.15.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-15-2-4-1">
<p>
\(O(n)\).
</p>
</div>
</div>

<div id="outline-container-org8e021d0" class="outline-6">
<h6 id="org8e021d0"><span class="section-number-6">2.15.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-15-2-4-2">
<p>
\(O(n)\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgcfe51be" class="outline-5">
<h5 id="orgcfe51be"><span class="section-number-5">2.15.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-15-2-5">
<p>
There are <a href="https://leetcode.com/problems/climbing-stairs/solution/">6 approaches</a> on Leetcode.
</p>
<ol class="org-ol">
<li>Approach 1 is brute force.</li>
<li>Approaches 2 to 4 are essentially the same as my solution.</li>
<li>Approach 5 uses <i>Binets Method</i>, which uses matrix multiplication to obtain the \(n^{th}\) Fibonacci number. Its time complexity is \(\log(n)\). Space complexity is \(O(1)\).</li>
<li>Approach 6 just uses the Fibonacci Formula to calculate the \(n^{th}\) Fibonacci number. It is asymptotically the same as approach 5. However, precision of calculation is lost when <code>n</code> is big and the formula will give an incorrect number.</li>
</ol>
<p>
Here we take the formula solution.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span>70 Climbming stairs leetcode solution</label><pre class="src src-python" id="org2e3519e">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">climb_stairs</span>(n: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">sqrt5</span>=<span class="org-builtin">pow</span>(5, 1/2)
    <span class="org-variable-name">fibn</span> = <span class="org-builtin">pow</span>((1+sqrt5)/2, n+1)-<span class="org-builtin">pow</span>((1-sqrt5)/2,n+1)
    <span class="org-keyword">return</span> <span class="org-builtin">int</span>(fibn/sqrt5)
<span class="org-keyword">print</span>(climb_stairs(5))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">8
</pre>
</div>
</div>

<div id="outline-container-org0aa9a62" class="outline-6">
<h6 id="org0aa9a62"><span class="section-number-6">2.15.2.5.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org0a2be77" class="outline-6">
<h6 id="org0a2be77"><span class="section-number-6">2.15.2.5.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org30c5d67" class="outline-4">
<h4 id="org30c5d67"><span class="section-number-4">2.15.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-15-3">
</div>
<div id="outline-container-org964e4c2" class="outline-5">
<h5 id="org964e4c2"><span class="section-number-5">2.15.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-15-3-1">
<p>
It is amazing how we can optimise this seemingly daunting problem such dramatically from \(O(2^n)\) to \(\log(n)\)!.
</p>
</div>
</div>
<div id="outline-container-org62d242c" class="outline-5">
<h5 id="org62d242c"><span class="section-number-5">2.15.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-15-3-2">
<p>
<a href="#orgf710db8">2.16</a>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf710db8" class="outline-3">
<h3 id="orgf710db8"><span class="section-number-3">2.16.</span> <span class="done DONE">DONE</span> 746 Min cost climbing stairs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dp">dp</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-16">
</div>
<div id="outline-container-org50dfcd9" class="outline-4">
<h4 id="org50dfcd9"><span class="section-number-4">2.16.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-16-1">
<p>
On a staircase, the \(i^{th}\) step has some 0 indexed non-negative cost <code>cost[i]</code> assigned.
</p>

<p>
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0 or with index 1.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li><code>cost</code> will have a length in the range [2, 1000]</li>
<li>Every <code>cost[i]</code> will be an integer in the range [0, 999].</li>
</ol>
</div>
<div id="outline-container-org4cb36c0" class="outline-5">
<h5 id="org4cb36c0"><span class="section-number-5">2.16.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-16-1-1">
<pre class="example" id="org51b991e">
Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.

Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].
</pre>
</div>
</div>
</div>

<div id="outline-container-org15e9d7b" class="outline-4">
<h4 id="org15e9d7b"><span class="section-number-4">2.16.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-16-2">
</div>
<div id="outline-container-org6ff7026" class="outline-5">
<h5 id="org6ff7026"><span class="section-number-5">2.16.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org9ec9fbc" class="outline-5">
<h5 id="org9ec9fbc"><span class="section-number-5">2.16.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-16-2-2">
<p>
This is an optimal problem. The final problem, "minimum cost to reach the top of the floor" can be divided into two subproblems, namely, the minimum cost to reach to the previous two possible stairs. We have \(min_cost_n=min(min_cost_{n-1}, min_cost_{n-2})\), and that \(min_cost_{n-1}\) and \(min_cost_{n-2}\) have overlapping subsubproblems.
Therefore, we can use dynamic programming to solve this problem.
</p>
</div>
</div>
<div id="outline-container-orga121083" class="outline-5">
<h5 id="orga121083"><span class="section-number-5">2.16.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-16-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span>746 Min cost climbing stairs my solution</label><pre class="src src-python" id="org3a444bd">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">min_cost_climbing_stairs</span>(cost: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(cost)
    <span class="org-variable-name">min_cost</span> = [inf <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n)]

    min_cost[0], <span class="org-variable-name">min_cost</span>[1] = cost[0], cost[1]
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2, n):
        <span class="org-variable-name">min_cost</span>[i] = <span class="org-builtin">min</span>(min_cost[i-1], min_cost[i-2])+cost[i]

    <span class="org-keyword">return</span> <span class="org-builtin">min</span>(min_cost[n-1], min_cost[n-2])
<span class="org-keyword">print</span>(min_cost_climbing_stairs([1, 100, 1,1,1,100,1,1,100,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">6
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc936764" class="outline-5">
<h5 id="orgc936764"><span class="section-number-5">2.16.2.4.</span> Complexity</h5>
<div class="outline-text-5" id="text-2-16-2-4">
</div>
<div id="outline-container-orgba975ce" class="outline-6">
<h6 id="orgba975ce"><span class="section-number-6">2.16.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-16-2-4-1">
<p>
\(O(N)\).
</p>
</div>
</div>
<div id="outline-container-org849f030" class="outline-6">
<h6 id="org849f030"><span class="section-number-6">2.16.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-16-2-4-2">
<p>
\(O(N)\).
</p>
</div>
</div>
</div>
<div id="outline-container-746 Leetcode" class="outline-5">
<h5 id="746 Leetcode"><span class="section-number-5">2.16.2.5.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-746 Leetcode">
<p>
The explanation from Leetcode is not very intuitive or clear.
The concept is the same as mine, but the way it explains things is very twisted.
</p>

<p>
Basically, they want <code>i in range(n, 1, -1)</code>, and then calculate each <code>f[i]</code> which is the total cost of the current floor.
</p>
<blockquote id="org6ab9cfc">
<p>
Intuition: 
There is a clear recursion available: the final cost f[i] to climb the staircase from some step i is f[i] = cost[i] + min(f[i+1], f[i+2]). This motivates dynamic programming.
</p>

<p>
Algorithm:
Let's evaluate f backwards in order. That way, when we are deciding what f[i] will be, we've already figured out f[i+1] and f[i+2].
</p>

<p>
We can do even better than that. At the i-th step, let f1, f2 be the old value of f[i+1], f[i+2], and update them to be the new values f[i], f[i+1]. We keep these updated as we iterate through i backwards. At the end, we want min(f1, f2).
</p>
</blockquote>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span>746 Min cost climbing stairs leetcode solution</label><pre class="src src-python" id="org2bf5269">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">min_cost_climbing_stairs</span>(cost: List[<span class="org-builtin">int</span>]):
    <span class="org-variable-name">f1</span> = <span class="org-variable-name">f2</span> = 0
    <span class="org-keyword">for</span> x <span class="org-keyword">in</span> <span class="org-builtin">reversed</span>(cost):
        <span class="org-variable-name">f1</span>, <span class="org-variable-name">f2</span>=x+<span class="org-builtin">min</span>(f1, f2), f1

    <span class="org-keyword">return</span> <span class="org-builtin">min</span>(f1, f2)
<span class="org-keyword">print</span>(min_cost_climbing_stairs([10,14,10]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">14
</pre>
</div>

<p>
Based on the <a href="#746 Leetcode">Leetcode solution</a>, we can improve our code to get \(O(1)\) space complexity.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span>746 Min cost climbing stairs my solution improved</label><pre class="src src-python" id="orgc25172d">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">min_cost_climbing_stairs</span>(cost: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(cost)

    <span class="org-variable-name">mc1</span>, <span class="org-variable-name">mc2</span> = cost[0], cost[1]

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2, n):
        <span class="org-variable-name">mc1</span>, <span class="org-variable-name">mc2</span> = mc2, <span class="org-builtin">min</span>(mc1, mc2)+cost[i]

    <span class="org-keyword">return</span> <span class="org-builtin">min</span>(mc1, mc2)
<span class="org-keyword">print</span>(min_cost_climbing_stairs([1, 100, 1,1,1,100,1,1,100,1]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">6
</pre>
</div>
</div>
<div id="outline-container-orgce04522" class="outline-6">
<h6 id="orgce04522"><span class="section-number-6">2.16.2.5.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-16-2-5-1">
<p>
\(O(N)\)
</p>
</div>
</div>
<div id="outline-container-org67a4a98" class="outline-6">
<h6 id="org67a4a98"><span class="section-number-6">2.16.2.5.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-16-2-5-2">
<p>
\(O(1)\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfeca108" class="outline-4">
<h4 id="orgfeca108"><span class="section-number-4">2.16.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-16-3">
</div>
<div id="outline-container-org4316502" class="outline-5">
<h5 id="org4316502"><span class="section-number-5">2.16.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-16-3-1">
<p>
Again, to determine if a question fits dynamic programming, we want to determine if:
</p>
<ol class="org-ol">
<li>It asks for an optimal solution</li>
<li>It can be divided into finding the optimal solution to subproblems</li>
<li>The subproblems have overlapping subsubproblems
<ol class="org-ol">
<li>DP's goal is to only solve these overlapping problems once to save time</li>
</ol></li>
<li>A recursive definition of the optimal solution can be found</li>
</ol>
</div>
</div>
<div id="outline-container-org912fcfb" class="outline-5">
<h5 id="org912fcfb"><span class="section-number-5">2.16.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-16-3-2">
<p>
<a href="#org25c4cd7">2.15</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf765329" class="outline-3">
<h3 id="orgf765329"><span class="section-number-3">2.17.</span> <span class="done DONE">DONE</span> 703 Kth largest element in a stream&#xa0;&#xa0;&#xa0;<span class="tag"><span class="heap">heap</span></span></h3>
<div class="outline-text-3" id="text-2-17">
</div>
<div id="outline-container-orgebcce04" class="outline-4">
<h4 id="orgebcce04"><span class="section-number-4">2.17.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-17-1">
<p>
Design a class to find the <b>K</b> th largest element in a stream. Note that it is the kth largest element in
the sorted order, not the kth distinct element.
</p>

<p>
Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array
<code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>,
return the element representing the kth largest element in the modified stream.
</p>

<p>
Constraints:
You may assume that <code>nums.length&gt;=k-1</code> and <code>k&gt;=1</code>.
</p>
</div>
<div id="outline-container-org24717cc" class="outline-5">
<h5 id="org24717cc"><span class="section-number-5">2.17.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-17-1-1">
<pre class="example" id="orge71cec7">
int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8
</pre>
</div>
</div>
</div>

<div id="outline-container-org2bc11a6" class="outline-4">
<h4 id="org2bc11a6"><span class="section-number-4">2.17.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-17-2">
</div>
<div id="outline-container-org2329ffa" class="outline-5">
<h5 id="org2329ffa"><span class="section-number-5">2.17.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org080f42f" class="outline-5">
<h5 id="org080f42f"><span class="section-number-5">2.17.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-17-2-2">
<p>
See <a href="#org27f93ab">6.4</a>.
</p>

<p>
Brute-force algorithm:
</p>
<ul class="org-ul">
<li>constructing the object
<ul class="org-ul">
<li>simply sort the <code>nums</code> array and store it in <code>self.nums</code></li>
</ul></li>
<li>running the <code>KthLargest.add(val)</code> method
<ul class="org-ul">
<li>insert the <code>val</code> in to the sorted <code>self.nums</code>, then get <code>self.nums[2]</code></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org308d812" class="outline-5">
<h5 id="org308d812"><span class="section-number-5">2.17.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-17-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span>703 Kth largest element in a stream my solution</label><pre class="src src-python" id="org7820380">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">class</span> <span class="org-type">KthLargest</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, k: <span class="org-builtin">int</span>, nums: List[<span class="org-builtin">int</span>]):
        <span class="org-keyword">self</span>.k = k
        <span class="org-keyword">self</span>.nums = <span class="org-builtin">sorted</span>(nums, reverse=<span class="org-constant">True</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">add</span>(<span class="org-keyword">self</span>, val: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.nums)):
            <span class="org-keyword">if</span> val &gt; <span class="org-keyword">self</span>.nums[i]:
                <span class="org-keyword">self</span>.nums.insert(i, val)
                <span class="org-keyword">break</span>

        <span class="org-keyword">else</span>:
            <span class="org-keyword">self</span>.nums.append(val)

        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.nums[<span class="org-keyword">self</span>.k-1]

<span class="org-variable-name">k</span>=3
<span class="org-variable-name">arr</span>=[4,5,8,2]
<span class="org-variable-name">obj</span> = KthLargest(k, arr)
<span class="org-keyword">print</span>(obj.add(3))
<span class="org-keyword">print</span>(obj.add(5))
<span class="org-keyword">print</span>(obj.add(10))
<span class="org-keyword">print</span>(obj.add(9))
<span class="org-keyword">print</span>(obj.add(4))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span>703 Kth largest element in a stream my solution-results</label><pre class="src src-none" id="org35942a9">4
5
5
8
8
</pre>
</div>
</div>
<div id="outline-container-org5fd3de9" class="outline-6">
<h6 id="org5fd3de9"><span class="section-number-6">2.17.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-17-2-3-1">
</div>
<ol class="org-ol">
<li><a id="orgc72900e"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-17-2-3-1-1">
<p>
Initial sorting: \(O(n\lg n)\).
The <code>add</code> method: \(O(n)\).
</p>
</div>
</li>
<li><a id="org11164e4"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-17-2-3-1-2">
<p>
\(O(n)\).
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-703 Leetcode" class="outline-5">
<h5 id="703 Leetcode"><span class="section-number-5">2.17.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-703 Leetcode">
<p>
Not available.
</p>

<p>
<a href="#org127f7b6">6.7.4</a> was used by many to solve the problem.
</p>

<p>
The question was probably asking us to implement the (max) priority queue.
</p>

<p>
The following <a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/discuss/563924/Easy-to-Understand-or-HeapQ-or-Simple-or-Python-Solution">solution</a> uses Python's <code>heapq</code> data structure.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span>703 Kth largest element in a stream leetcode solution</label><pre class="src src-python" id="org7a827d9">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">import</span> heapq
<span class="org-keyword">class</span> <span class="org-type">KthLargest</span>:

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, k: <span class="org-builtin">int</span>, nums: List[<span class="org-builtin">int</span>]):
        <span class="org-keyword">self</span>.arr = []
        <span class="org-keyword">self</span>.n = k
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> nums: <span class="org-keyword">self</span>._push(i)

    <span class="org-keyword">def</span> <span class="org-function-name">_push</span>(<span class="org-keyword">self</span>, val: <span class="org-builtin">int</span>):
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.arr) == <span class="org-keyword">self</span>.n:
            <span class="org-variable-name">top</span> = heapq.heappop(<span class="org-keyword">self</span>.arr)
            <span class="org-keyword">if</span> top &gt; val:
                heapq.heappush(<span class="org-keyword">self</span>.arr, top)
            <span class="org-keyword">else</span>:
                heapq.heappush(<span class="org-keyword">self</span>.arr, val)

        <span class="org-keyword">else</span>:
            heapq.heappush(<span class="org-keyword">self</span>.arr, val)

    <span class="org-keyword">def</span> <span class="org-function-name">add</span>(<span class="org-keyword">self</span>, val: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-keyword">self</span>._push(val)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.arr[0] <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.arr) <span class="org-keyword">else</span> <span class="org-constant">None</span>

<span class="org-variable-name">nums</span> = [10,9,8,7]
<span class="org-variable-name">k</span>=3
<span class="org-variable-name">obj</span> = KthLargest(k, nums)
<span class="org-variable-name">val</span>=6
<span class="org-variable-name">param_1</span> = obj.add(val)
<span class="org-keyword">print</span>(param_1)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span>703 Kth largest element in a stream leetcode solution-results</label><pre class="src src-none" id="org86e4ff4">8
</pre>
</div>
</div>
<div id="outline-container-orgde0472a" class="outline-6">
<h6 id="orgde0472a"><span class="section-number-6">2.17.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-17-2-4-1">
<p>
Initial sorting: \(O(n\lg n)\).
The <code>add()</code> method: \(O(\lg n)\).
</p>
</div>
</div>
<div id="outline-container-orgd6c13f5" class="outline-6">
<h6 id="orgd6c13f5"><span class="section-number-6">2.17.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-17-2-4-2">
<p>
\(O(n)\).
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc677c91" class="outline-4">
<h4 id="orgc677c91"><span class="section-number-4">2.17.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-17-3">
</div>
<div id="outline-container-org880e938" class="outline-5">
<h5 id="org880e938"><span class="section-number-5">2.17.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-17-3-1">
<p>
The <code>heapq</code> provided by Python follows min-heap properties.
</p>
<ul class="org-ul">
<li><code>arr[0]</code> is the smallest element</li>
<li><code>arr[k]&lt;arr[2k+1], arr[k]&lt;arr[2k+2]</code></li>
</ul>

<p>
We can modify the <a href="#703 Leetcode">Leetcode solution</a> to make it use less memory in theory since we are dealing with a stream and do not care about storing it.
Basically, we chop off the list after each <code>add(val)</code> operation, so the list has only <code>k</code> elements.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 42: </span>703 Kth largest element in a stream leetcode solution improved</label><pre class="src src-python" id="orgd56b0ac">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">class</span> <span class="org-type">KthLargest</span>:
    <span class="org-keyword">import</span> heapq

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, k: <span class="org-builtin">int</span>, nums: List[<span class="org-builtin">int</span>]):
        <span class="org-keyword">self</span>.k = k
        <span class="org-keyword">self</span>.arr = nums
        heapq.heapify(<span class="org-keyword">self</span>.arr)
        <span class="org-keyword">self</span>._chop_off_queue()

    <span class="org-keyword">def</span> <span class="org-function-name">add</span>(<span class="org-keyword">self</span>, val: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-variable-name">heap_top</span> = 0

        <span class="org-comment-delimiter"># </span><span class="org-comment">always keep heap size = k</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Top element = kth largest element</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.arr) &lt; <span class="org-keyword">self</span>.k:
            heapq.heappush(<span class="org-keyword">self</span>.arr, val)
        <span class="org-keyword">else</span>:
            heapq.heappushpop(<span class="org-keyword">self</span>.arr, val)

        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.arr[heap_top]


    <span class="org-keyword">def</span> <span class="org-function-name">_chop_off_queue</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">while</span> <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.arr) &gt; <span class="org-keyword">self</span>.k:
            <span class="org-comment-delimiter"># </span><span class="org-comment">heappop() pops the smallest element</span>
            heapq.heappop(<span class="org-keyword">self</span>.arr)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1947297" class="outline-5">
<h5 id="org1947297"><span class="section-number-5">2.17.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-17-3-2">
<p>
See <a href="#org4a73e2a">6.3.1</a> and <a href="#org127f7b6">6.7.4</a>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf293133" class="outline-3">
<h3 id="orgf293133"><span class="section-number-3">2.18.</span> <span class="done DONE">DONE</span> 215 Kth largest element in an array&#xa0;&#xa0;&#xa0;<span class="tag"><span class="heap">heap</span></span></h3>
<div class="outline-text-3" id="text-2-18">
</div>
<div id="outline-container-org365f155" class="outline-4">
<h4 id="org365f155"><span class="section-number-4">2.18.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-18-1">
<p>
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
</p>

<p>
Constraints:
You may assume k is always valid, 1 â‰¤ k â‰¤ array's length.
</p>
</div>
<div id="outline-container-org44ed95d" class="outline-5">
<h5 id="org44ed95d"><span class="section-number-5">2.18.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-18-1-1">
<pre class="example" id="orgd699660">
Input: [3,2,1,5,6,4] and k = 2
Output: 5

Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
</pre>
</div>
</div>
</div>

<div id="outline-container-org7988de9" class="outline-4">
<h4 id="org7988de9"><span class="section-number-4">2.18.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-18-2">
</div>
<div id="outline-container-org2d05945" class="outline-5">
<h5 id="org2d05945"><span class="section-number-5">2.18.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org7ac8c42" class="outline-5">
<h5 id="org7ac8c42"><span class="section-number-5">2.18.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-18-2-2">
<p>
We can use quicksort.
</p>

<p>
See <a href="#org27f93ab">6.4</a> for theory discussion and linear time algorithm (randomized quickselect).
</p>
</div>
</div>
<div id="outline-container-org3928505" class="outline-5">
<h5 id="org3928505"><span class="section-number-5">2.18.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-18-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 43: </span>215 Kth largest element in an array my solution</label><pre class="src src-python" id="org08da740">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">find_kth_largest</span>(nums: List[<span class="org-builtin">int</span>], k: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">return</span> <span class="org-builtin">sorted</span>(nums)[k-1]
<span class="org-keyword">print</span>(find_kth_largest([3,2,1,5,6,4], 2))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 44: </span>215 Kth largest element in an array my solution-results</label><pre class="src src-none" id="org24b164c">2
</pre>
</div>

<p>
Quickselect implementation (a replica of <a href="#orgedf6f64">6.4.2</a>).
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 45: </span>quickselect implementation</label><pre class="src src-python" id="org6ce9505">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">import</span> random

<span class="org-keyword">def</span> <span class="org-function-name">kth_largest</span>(arr: List[<span class="org-builtin">int</span>], k: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">partition</span>(arr, lo, hi):
        <span class="org-variable-name">pivot</span> = arr[hi]
        <span class="org-variable-name">i</span> = lo

        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(lo, hi):
            <span class="org-keyword">if</span> arr[j] &gt; pivot:
                arr[i], <span class="org-variable-name">arr</span>[j] = arr[j], arr[i]
                <span class="org-variable-name">i</span> += 1

        arr[i], <span class="org-variable-name">arr</span>[hi] = arr[hi], arr[i]
        <span class="org-keyword">return</span> i
    
    <span class="org-keyword">def</span> <span class="org-function-name">quickselect</span>(arr: List[<span class="org-builtin">int</span>],lo, hi, k) -&gt; <span class="org-builtin">int</span>:
        <span class="org-variable-name">rand_pivot_idx</span> = random.randrange(lo, hi+1)
        arr[hi], <span class="org-variable-name">arr</span>[rand_pivot_idx] = arr[rand_pivot_idx], arr[hi]
        <span class="org-variable-name">par</span> = partition(arr, lo, hi)
        
        <span class="org-keyword">if</span> par == k - 1:
            <span class="org-keyword">return</span> arr[par]
        <span class="org-keyword">elif</span> par &gt; k-1:
            <span class="org-keyword">return</span> quickselect(arr, lo, par-1, k)
        <span class="org-keyword">return</span> quickselect(arr, par+1, hi, k)
    
    <span class="org-keyword">return</span> quickselect(arr, 0, <span class="org-builtin">len</span>(arr)-1, k)

<span class="org-keyword">print</span>(kth_largest([3,2,1,5,6,4], 3))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 46: </span>quickselect implementation-results</label><pre class="src src-none">4
</pre>
</div>
</div>
<div id="outline-container-orgdcea393" class="outline-6">
<h6 id="orgdcea393"><span class="section-number-6">2.18.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-18-2-3-1">
</div>
<ol class="org-ol">
<li><a id="orgc058141"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-18-2-3-1-1">
<p>
\(O(n\lg n)\).
</p>
</div>
</li>
<li><a id="org181f2e9"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-18-2-3-1-2">
<p>
\(O(1)\). Quicksort is in-place.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgaa9f09d" class="outline-5">
<h5 id="orgaa9f09d"><span class="section-number-5">2.18.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-18-2-4">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 47: </span>215 Kth largest element in an array leetcode solution</label><pre class="src src-python" id="orgddb6b22">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 48: </span>215 Kth largest element in an array leetcode solution-results</label><pre class="src src-none" id="orgc10a7b0">
</pre>
</div>
</div>
<div id="outline-container-org1a5674a" class="outline-6">
<h6 id="org1a5674a"><span class="section-number-6">2.18.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-orgff85c75" class="outline-6">
<h6 id="orgff85c75"><span class="section-number-6">2.18.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgc74471d" class="outline-4">
<h4 id="orgc74471d"><span class="section-number-4">2.18.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-18-3">
</div>
<div id="outline-container-org514575c" class="outline-5">
<h5 id="org514575c"><span class="section-number-5">2.18.3.1.</span> General thoughts</h5>
</div>

<div id="outline-container-org711d6f6" class="outline-5">
<h5 id="org711d6f6"><span class="section-number-5">2.18.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-18-3-2">
<p>
<a href="#orgf765329">2.17</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org10fac48" class="outline-3">
<h3 id="org10fac48"><span class="section-number-3">2.19.</span> <span class="done DONE">DONE</span> 973 K closest points to origin&#xa0;&#xa0;&#xa0;<span class="tag"><span class="heap">heap</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-19">
</div>
<div id="outline-container-orgae173d2" class="outline-4">
<h4 id="orgae173d2"><span class="section-number-4">2.19.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-19-1">
<p>
We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>The distance between two points is the Euclidean distance</li>
<li>The answer is unique, but its elements can be in any order.</li>
<li>\(1\le K \le points.length \le 10000\)</li>
<li>\(-10000<points[i][0]<10000\)</li>
<li>\(-10000<points[i][1]<10000\)</li>
</ol>
</div>
<div id="outline-container-org10b4de6" class="outline-5">
<h5 id="org10b4de6"><span class="section-number-5">2.19.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-19-1-1">
<pre class="example" id="org241c40e">
Input: points = [[1,3], [-2,2]], k=1
Output: [[-2,2]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org52e74af" class="outline-4">
<h4 id="org52e74af"><span class="section-number-4">2.19.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-19-2">
</div>
<div id="outline-container-org28ed6c4" class="outline-5">
<h5 id="org28ed6c4"><span class="section-number-5">2.19.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org217ecb7" class="outline-5">
<h5 id="org217ecb7"><span class="section-number-5">2.19.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-19-2-2">
<p>
We can treat this input of <code>points</code> as a stream and use a priority queue to store each point
as we iterate through <code>points</code>.
</p>

<p>
Once we process all points, we just return the last <code>k</code> elements.
</p>
</div>
</div>
<div id="outline-container-orge06465a" class="outline-5">
<h5 id="orge06465a"><span class="section-number-5">2.19.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-19-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 49: </span>973 K closest points to origin my solution</label><pre class="src src-python" id="orgc9cdd31">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">import</span> heapq

<span class="org-keyword">def</span> <span class="org-function-name">k_closest_points</span>(points: List[List[<span class="org-builtin">int</span>]], K: <span class="org-builtin">int</span>) -&gt; List[List[<span class="org-builtin">int</span>]]:
    <span class="org-keyword">def</span> <span class="org-function-name">get_distance</span>(x, y) -&gt; <span class="org-builtin">float</span>:
        <span class="org-keyword">return</span> (x**2+y**2)

    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(points) == K:
        <span class="org-keyword">return</span> points

    <span class="org-variable-name">pq</span> = []

    <span class="org-comment-delimiter"># </span><span class="org-comment">this takes O(n)</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">because it is essentially heapify()</span>
    <span class="org-keyword">for</span> point <span class="org-keyword">in</span> points:
        <span class="org-variable-name">distance</span> = get_distance(*point)
        heapq.heappush(pq, (distance, point))

    <span class="org-keyword">return</span> [heapq.heappop(pq)[1] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(K)]

<span class="org-keyword">print</span>(k_closest_points([[1,3],[2,-2]], 2))
<span class="org-keyword">print</span>(k_closest_points([[1,3],[2,-2], [2,-3]], 2))
<span class="org-keyword">print</span>(k_closest_points([[3,3],[5,-1], [-2,4], [3,4]], 3))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 50: </span>973 K closest points to origin my solution-results</label><pre class="src src-none" id="orgcd5c796">[[1, 3], [2, -2]]
[[2, -2], [1, 3]]
[[3, 3], [-2, 4], [3, 4]]
</pre>
</div>
</div>
<div id="outline-container-orgd2dcf4f" class="outline-6">
<h6 id="orgd2dcf4f"><span class="section-number-6">2.19.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-19-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org2d2df5c"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-19-2-3-1-1">
<p>
\(O(K\lg n)\), the last line takes the most time asymptotically.
</p>
</div>
</li>
<li><a id="org9ad8ebe"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-19-2-3-1-2">
<p>
\(O(n)\)
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org3435ac6" class="outline-5">
<h5 id="org3435ac6"><span class="section-number-5">2.19.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-19-2-4">
<p>
Uses <a href="#orgedf6f64">Quickselect</a>.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 51: </span>973 K closest points to origin leetcode solution</label><pre class="src src-python" id="org27b13c8">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;
<span class="org-keyword">class</span> <span class="org-type">Solution</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">kClosest</span>(<span class="org-keyword">self</span>, points, K):
        <span class="org-variable-name">dist</span> = <span class="org-keyword">lambda</span> i: points[i][0]**2 + points[i][1]**2

        <span class="org-keyword">def</span> <span class="org-function-name">sort</span>(i, j, K):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Partially sorts A[i:j+1] so the first K elements are</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">the smallest K elements.</span>
            <span class="org-keyword">if</span> i &gt;= j: <span class="org-keyword">return</span>

            <span class="org-comment-delimiter"># </span><span class="org-comment">Put random element as A[i] - this is the pivot</span>
            <span class="org-variable-name">k</span> = random.randint(i, j)
            points[i], <span class="org-variable-name">points</span>[k] = points[k], points[i]

            <span class="org-variable-name">mid</span> = partition(i, j)
            <span class="org-keyword">if</span> K &lt; mid - i + 1:
                sort(i, mid - 1, K)
            <span class="org-keyword">elif</span> K &gt; mid - i + 1:
                sort(mid + 1, j, K - (mid - i + 1))

        <span class="org-keyword">def</span> <span class="org-function-name">partition</span>(i, j):
            <span class="org-comment-delimiter"># </span><span class="org-comment">Partition by pivot A[i], returning an index mid</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">such that A[i] &lt;= A[mid] &lt;= A[j] for i &lt; mid &lt; j.</span>
            <span class="org-variable-name">oi</span> = i
            <span class="org-variable-name">pivot</span> = dist(i)
            <span class="org-variable-name">i</span> += 1

            <span class="org-keyword">while</span> <span class="org-constant">True</span>:
                <span class="org-keyword">while</span> i &lt; j <span class="org-keyword">and</span> dist(i) &lt; pivot:
                    <span class="org-variable-name">i</span> += 1
                <span class="org-keyword">while</span> i &lt;= j <span class="org-keyword">and</span> dist(j) &gt;= pivot:
                    <span class="org-variable-name">j</span> -= 1
                <span class="org-keyword">if</span> i &gt;= j: <span class="org-keyword">break</span>
                points[i], <span class="org-variable-name">points</span>[j] = points[j], points[i]

            points[oi], <span class="org-variable-name">points</span>[j] = points[j], points[oi]
            <span class="org-keyword">return</span> j

        sort(0, <span class="org-builtin">len</span>(points) - 1, K)
        <span class="org-keyword">return</span> points[:K]
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 52: </span>973 K closest points to origin leetcode solution-results</label><pre class="src src-none" id="org3eac1ad">
</pre>
</div>
</div>
<div id="outline-container-orge6dec85" class="outline-6">
<h6 id="orge6dec85"><span class="section-number-6">2.19.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-19-2-4-1">
<p>
\(O(n^2)\) worst case, average case \(O(n)\).
</p>
</div>
</div>
<div id="outline-container-org7e78d97" class="outline-6">
<h6 id="org7e78d97"><span class="section-number-6">2.19.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-19-2-4-2">
<p>
\(O(n)\).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga6ad602" class="outline-4">
<h4 id="orga6ad602"><span class="section-number-4">2.19.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-19-3">
</div>
<div id="outline-container-org56579d1" class="outline-5">
<h5 id="org56579d1"><span class="section-number-5">2.19.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-orgff6066a" class="outline-5">
<h5 id="orgff6066a"><span class="section-number-5">2.19.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-19-3-2">
<p>
Any problem that asks for "Closest", "Smallest", "Largest", <b>K</b> elements.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org1866d4f" class="outline-3">
<h3 id="org1866d4f"><span class="section-number-3">2.20.</span> <span class="done DONE">DONE</span> 347 Top K frequent elements&#xa0;&#xa0;&#xa0;<span class="tag"><span class="heap">heap</span>&#xa0;<span class="medium">medium</span></span></h3>
<div class="outline-text-3" id="text-2-20">
</div>
<div id="outline-container-org91d71dd" class="outline-4">
<h4 id="org91d71dd"><span class="section-number-4">2.20.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-20-1">
<p>
Given a non-empty array of integers, return the \(k\) most frequent elements.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>You may assume k is always valid, 1 â‰¤ k â‰¤ number of unique elements.</li>
<li>Your algorithm's time complexity must be better than O(n log n), where n is the array's size.</li>
<li>It's guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.</li>
<li>You can return the answer in any order.</li>
</ol>
</div>
<div id="outline-container-orgc400887" class="outline-5">
<h5 id="orgc400887"><span class="section-number-5">2.20.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-20-1-1">
<pre class="example" id="org4e1f2ee">
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Input: nums = [1], k = 1
Output: [1]
</pre>
</div>
</div>
</div>

<div id="outline-container-orga14b200" class="outline-4">
<h4 id="orga14b200"><span class="section-number-4">2.20.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-20-2">
</div>
<div id="outline-container-orgd6faacc" class="outline-5">
<h5 id="orgd6faacc"><span class="section-number-5">2.20.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org9362296" class="outline-5">
<h5 id="org9362296"><span class="section-number-5">2.20.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-20-2-2">
<p>
It's obvious that we have to use quickselect to achieve \(O(n)\) time complexity on average.
</p>

<p>
We first scan the array and build a cound of elements (\(O(n)\)).
We then quick-select the counts and get the \(k\) elements (\(O(n)\)).
</p>
</div>
</div>
<div id="outline-container-org6fead69" class="outline-5">
<h5 id="org6fead69"><span class="section-number-5">2.20.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-20-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 53: </span>347 Top K frequent elements my solution</label><pre class="src src-python" id="org5fdeb40">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">top_k_frequent</span>(nums: List[<span class="org-builtin">int</span>], k: <span class="org-builtin">int</span>) -&gt; List[<span class="org-builtin">int</span>]:
    <span class="org-keyword">def</span> <span class="org-function-name">partition</span>(arr, low, high):
        <span class="org-variable-name">pivot</span> = arr[high]
        <span class="org-variable-name">i</span> = low
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(low, high):
            <span class="org-keyword">if</span> arr[j][1] &gt;= pivot[1]:
                arr[j], <span class="org-variable-name">arr</span>[i] = arr[i], arr[j]
                <span class="org-variable-name">i</span> += 1

        arr[i], <span class="org-variable-name">arr</span>[high] = arr[high], arr[i]
        <span class="org-keyword">return</span> i

    <span class="org-keyword">def</span> <span class="org-function-name">quickselect</span>(arr, low, high, k: <span class="org-builtin">int</span>) -&gt; List[<span class="org-builtin">int</span>]:

        <span class="org-variable-name">par</span> = partition(arr, low, high)

        <span class="org-keyword">if</span> par == k-1:
            <span class="org-keyword">return</span> arr[:k]
        <span class="org-keyword">elif</span> par &lt; k-1:
            <span class="org-keyword">return</span> quickselect(arr, par+1, high, k)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> quickselect(arr, low, par-1, k)
        
    <span class="org-variable-name">temp</span> = {}
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> nums:
        <span class="org-variable-name">temp</span>[i] = temp.get(i, 0) + 1
        <span class="org-variable-name">arr</span> = [(k, v) <span class="org-keyword">for</span> k, v <span class="org-keyword">in</span> temp.items()]
    <span class="org-keyword">return</span> [i[0] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> quickselect(arr, 0, <span class="org-builtin">len</span>(arr)-1, k)]

<span class="org-keyword">print</span>(top_k_frequent([1,1,1,2,2,3], 2))
<span class="org-keyword">print</span>(top_k_frequent([1,1,1,2,2,3,3,3], 2))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 54: </span>347 Top K frequent elements my solution-results</label><pre class="src src-none" id="org1731115">[1, 2]
[1, 3]
</pre>
</div>
</div>
<div id="outline-container-org8c46911" class="outline-6">
<h6 id="org8c46911"><span class="section-number-6">2.20.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-20-2-3-1">
</div>
<ol class="org-ol">
<li><a id="orgb16c4a8"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-20-2-3-1-1">
<p>
\(O(n)\) on average, \(O(n^2)\) worst case.
</p>
</div>
</li>
<li><a id="org2d0f31b"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-20-2-3-1-2">
<p>
\(O(n)\).
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org29da0c3" class="outline-5">
<h5 id="org29da0c3"><span class="section-number-5">2.20.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-20-2-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 55: </span>347 Top K frequent elements leetcode solution</label><pre class="src src-python" id="org962ebb4">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">top_k_frequent</span>(nums, k):
    <span class="org-keyword">from</span> collections <span class="org-keyword">import</span> Counter
    <span class="org-keyword">import</span> heapq

    <span class="org-variable-name">count</span> = Counter(nums)
    <span class="org-keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)

<span class="org-keyword">print</span>(top_k_frequent([1,1,1,2,3,2], 2))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 56: </span>347 Top K frequent elements leetcode solution-results</label><pre class="src src-none" id="org48433d4">[1, 2]
</pre>
</div>
</div>
<div id="outline-container-org86c7a4f" class="outline-6">
<h6 id="org86c7a4f"><span class="section-number-6">2.20.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-20-2-4-1">
<p>
\(O(n \lg k)\)
</p>
</div>
</div>
<div id="outline-container-orgdfd59fd" class="outline-6">
<h6 id="orgdfd59fd"><span class="section-number-6">2.20.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-20-2-4-2">
<p>
\(O(n)\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb0d0a19" class="outline-4">
<h4 id="orgb0d0a19"><span class="section-number-4">2.20.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-20-3">
</div>
<div id="outline-container-org94255c0" class="outline-5">
<h5 id="org94255c0"><span class="section-number-5">2.20.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-20-3-1">
<p>
My solution uses Quickselect without randomization, which means that some particular array setup could 
hit it hard and run at \(O(n^2)\), but in general, it works at \(O(n)\).
</p>

<p>
Another quick hack to this is to use <code>Counter</code> object.
When \(k<n\), this uses <code>heapq.nlargest()</code> internally, which gives us \(O(n\lg k)\) time complexity.
When \(k==n\), this uses <code>sorted</code> internally, which also gives us \(O(n\lg k)\) time complexity.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 57: </span>most<sub>common</sub></label><pre class="src src-python" id="org2238c8e"><span class="org-keyword">from</span> collections <span class="org-keyword">import</span> Counter

<span class="org-keyword">def</span> <span class="org-function-name">top_k_frequent</span>(nums, k):
    <span class="org-variable-name">count</span> = Counter(nums)
    <span class="org-keyword">return</span> [i[0] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> count.most_common(k)]
<span class="org-keyword">print</span>(top_k_frequent([1,2,1,1,24,2], 2))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[1, 2]
</pre>
</div>

<p>
Seems we can also use bucket sort.
</p>
</div>
</div>
<div id="outline-container-orgd8c15e4" class="outline-5">
<h5 id="orgd8c15e4"><span class="section-number-5">2.20.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org500ab80" class="outline-3">
<h3 id="org500ab80"><span class="section-number-3">2.21.</span> <span class="done DONE">DONE</span> 355 Design twitter&#xa0;&#xa0;&#xa0;<span class="tag"><span class="medium">medium</span>&#xa0;<span class="heap">heap</span></span></h3>
<div class="outline-text-3" id="text-2-21">
</div>
<div id="outline-container-org18ebe99" class="outline-4">
<h4 id="org18ebe99"><span class="section-number-4">2.21.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-21-1">
<p>
Design a simplified version of Twitter where users can post tweets, follow/unfollow
another user and is able to see the 10 most recent tweets in the user's news feed.
Your design should support the following methods:
</p>
<ol class="org-ol">
<li><code>postTweet(userId, tweetId)</code>: compose a new tweet.</li>
<li><code>geNewsFeed(userId)</code>: Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>
<li><code>follow(followerId, followeeId)</code>: follower follows a followee.</li>
<li>unfollow(followerId, followeeId): Follower unfollows a followee.</li>
</ol>

<p>
Constraints: None.
</p>
</div>

<div id="outline-container-org6d5defc" class="outline-5">
<h5 id="org6d5defc"><span class="section-number-5">2.21.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-21-1-1">
<pre class="example" id="org001ee9b">
Twitter twitter = new Twitter();

// User 1 posts a new tweet (id = 5).
twitter.postTweet(1, 5);

// User 1's news feed should return a list with 1 tweet id -&gt; [5].
twitter.getNewsFeed(1);

// User 1 follows user 2.
twitter.follow(1, 2);

// User 2 posts a new tweet (id = 6).
twitter.postTweet(2, 6);

// User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5].
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.getNewsFeed(1);

// User 1 unfollows user 2.
twitter.unfollow(1, 2);

// User 1's news feed should return a list with 1 tweet id -&gt; [5],
// since user 1 is no longer following user 2.
twitter.getNewsFeed(1);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7aa6887" class="outline-4">
<h4 id="org7aa6887"><span class="section-number-4">2.21.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-21-2">
</div>
<div id="outline-container-orge05b515" class="outline-5">
<h5 id="orge05b515"><span class="section-number-5">2.21.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-orgeae0ff6" class="outline-5">
<h5 id="orgeae0ff6"><span class="section-number-5">2.21.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-21-2-2">
<p>
We would have a set of <code>users</code> that stores all the users.
They have <code>tweets</code> ordrerd by time.
</p>

<p>
We also have a <code>newsfeed</code> for every user. This <code>newsfeed</code> is a priority queue built on timestamp and selects feeds from followees of current user.
</p>

<p>
We have <code>followers</code> and <code>followees</code> for any user.
</p>

<p>
We then map the <code>userId</code> to tade <code>newsfeed</code>.
</p>

<p>
We update <code>users</code> in <code>postTweet</code> for user A.
We update <code>newsfeed</code> in <code>follow</code> of user A.
We update <code>newsfeed</code> in <code>unfollow</code> of user A.
We update <code>newsfeed</code> in <code>postTweet</code> of user A's followees.
</p>

<p>
<code>newsfeed</code> has to maintain a length of 10 unless total number of tweets from <code>followees</code> is less than 10.
</p>
</div>
</div>
<div id="outline-container-org5b11293" class="outline-5">
<h5 id="org5b11293"><span class="section-number-5">2.21.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-21-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 58: </span>355 Desin twitter my solution</label><pre class="src src-python" id="org7987479">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">import</span> collections
<span class="org-keyword">from</span> datetime <span class="org-keyword">import</span> datetime
<span class="org-keyword">import</span> heapq

<span class="org-keyword">class</span> <span class="org-type">Twitter</span>:

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Initialize your data structure here.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">self</span>.users_tweets = collections.defaultdict(<span class="org-builtin">list</span>)
        <span class="org-keyword">self</span>.users_followers = collections.defaultdict(<span class="org-builtin">set</span>)
        <span class="org-keyword">self</span>.users_followees = collections.defaultdict(<span class="org-builtin">set</span>)
        <span class="org-keyword">self</span>.users_newsfeeds = collections.defaultdict(<span class="org-builtin">list</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">postTweet</span>(<span class="org-keyword">self</span>, userId: <span class="org-builtin">int</span>, tweetId: <span class="org-builtin">int</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Compose a new tweet.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">if this userId is new</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">ta must follow taself</span>
        <span class="org-keyword">self</span>.users_followees[userId].add(userId)
        <span class="org-keyword">self</span>.users_followers[userId].add(userId)
        <span class="org-comment-delimiter"># </span><span class="org-comment">add tweet to the userId</span>
        <span class="org-variable-name">tweet</span> = datetime.now(tz=<span class="org-constant">None</span>), tweetId
        <span class="org-keyword">self</span>.users_tweets[userId].append(tweet)
        <span class="org-comment-delimiter"># </span><span class="org-comment">update newsfeeds of the followers</span>
        <span class="org-keyword">for</span> user <span class="org-keyword">in</span> <span class="org-keyword">self</span>.users_followers[userId]:
            heapq.heappush(<span class="org-keyword">self</span>.users_newsfeeds[user], tweet)
            

    <span class="org-keyword">def</span> <span class="org-function-name">getNewsFeed</span>(<span class="org-keyword">self</span>, userId: <span class="org-builtin">int</span>) -&gt; List[<span class="org-builtin">int</span>]:
        <span class="org-doc">"""</span>
<span class="org-doc">        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</span>
<span class="org-doc">        """</span>

        <span class="org-variable-name">num_total_tweets</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.users_newsfeeds[userId])
        <span class="org-variable-name">num_tweets</span> = 10 <span class="org-keyword">if</span> num_total_tweets &gt; 10 <span class="org-keyword">else</span> num_total_tweets

        <span class="org-variable-name">res</span> = heapq.nlargest(num_tweets, <span class="org-keyword">self</span>.users_newsfeeds[userId])

        <span class="org-keyword">return</span> [i[1] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> res]

    <span class="org-keyword">def</span> <span class="org-function-name">follow</span>(<span class="org-keyword">self</span>, followerId: <span class="org-builtin">int</span>, followeeId: <span class="org-builtin">int</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Follower follows a followee. If the operation is invalid, it should be a no-op.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Only follow if followee is not followed by us</span>
        <span class="org-keyword">if</span> followeeId <span class="org-keyword">not</span> <span class="org-keyword">in</span> <span class="org-keyword">self</span>.users_followees[followerId]:
            <span class="org-keyword">self</span>.users_followees[followerId].add(followeeId)
            <span class="org-keyword">self</span>.users_followers[followeeId].add(followerId)

            <span class="org-comment-delimiter"># </span><span class="org-comment">get the tweets from new followee</span>
            <span class="org-keyword">for</span> tweet <span class="org-keyword">in</span> <span class="org-keyword">self</span>.users_tweets[followeeId]:
                heapq.heappush(<span class="org-keyword">self</span>.users_newsfeeds[followerId], tweet)

    <span class="org-keyword">def</span> <span class="org-function-name">unfollow</span>(<span class="org-keyword">self</span>, followerId: <span class="org-builtin">int</span>, followeeId: <span class="org-builtin">int</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Follower unfollows a followee. If the operation is invalid, it should be a no-op.</span>
<span class="org-doc">        """</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Do not unfollow oneself</span>
        <span class="org-keyword">if</span> followeeId == followerId:
            <span class="org-keyword">return</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Only unfollow if followee is followed by us</span>
        <span class="org-keyword">if</span> followeeId <span class="org-keyword">in</span> <span class="org-keyword">self</span>.users_followees[followerId]:

            <span class="org-comment-delimiter"># </span><span class="org-comment">remove followee (unfollow)</span>
            <span class="org-keyword">self</span>.users_followees[followerId].remove(followeeId)
            <span class="org-comment-delimiter"># </span><span class="org-comment">remove follower (unfollow)</span>
            <span class="org-keyword">self</span>.users_followers[followeeId].remove(followerId)
            <span class="org-comment-delimiter"># </span><span class="org-comment">remove tweets from folowee</span>
            <span class="org-keyword">for</span> tweet <span class="org-keyword">in</span> <span class="org-keyword">self</span>.users_tweets[followeeId]:
                <span class="org-keyword">self</span>.users_newsfeeds[followerId].remove(tweet)

            heapq.heapify(<span class="org-keyword">self</span>.users_newsfeeds[followerId])
            

<span class="org-comment-delimiter"># </span><span class="org-comment">Your Twitter object will be instantiated and called as such:</span>
<span class="org-variable-name">obj</span> = Twitter()

obj.postTweet(1, 5)
<span class="org-variable-name">param_2</span> = obj.getNewsFeed(1)
<span class="org-keyword">print</span>(param_2)
obj.follow(1, 2)
<span class="org-variable-name">param_2</span> = obj.getNewsFeed(1)
<span class="org-keyword">print</span>(param_2)
obj.postTweet(2, 6)
<span class="org-variable-name">param_2</span> = obj.getNewsFeed(1)
<span class="org-keyword">print</span>(param_2)
obj.unfollow(1, 2)
<span class="org-variable-name">param_2</span> = obj.getNewsFeed(1)
<span class="org-keyword">print</span>(param_2)

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 59: </span>355 Desin twitter my solution-results</label><pre class="src src-python" id="org3f06a8e">[5]
[5]
[6, 5]
[5]
</pre>
</div>
</div>
<div id="outline-container-org22cf4c3" class="outline-6">
<h6 id="org22cf4c3"><span class="section-number-6">2.21.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-21-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org756d8eb"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-21-2-3-1-1">
<ol class="org-ol">
<li><code>postTweet</code> takes \(O(k)\), where \(k\) is the number of followers \(userId\) has.</li>
<li><code>getNewsFeed</code> takes \(O(n \lg n)\) with <code>heapq.nlargest</code>, where \(n\) is the number of tweets in the user's news feed.</li>
<li><code>follow</code> takes \(O(n \lg k)\), where \(n\) is the number of tweets the <code>followee</code> has and \(k\) is the number of tweets in user's news feed. (this part can be improved significantly).</li>
<li><code>unfollow</code> takes \(O(n+m)\), where \(n\) is the number of tweets the <code>followee</code> has, \(m\) is the number of tweets in user's news feed.</li>
</ol>
</div>
</li>
<li><a id="orge269fe6"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-21-2-3-1-2">
<ol class="org-ol">
<li><code>users_tweets</code>: \(O(m\times n)\), where \(m\) is the number of users, and \(n\) is the number of tweets of each user.</li>
<li><code>users_followers</code>: \(O(m\times n)\), where \(m\) is the number of users, and \(n\) is the number of users who choose to follow a user.</li>
<li><code>users_followees</code>: \(O(m\times n)\), where \(m\) is the number of users, and \(n\) is the number of users who choose to follow a user. (this is not necessary)</li>
<li><code>users_newsfeeds</code>: \(O(m\times n)\), where \(m\) is the number of users and \(n\) is the number of tweets in their news feed. (We can also just keep 10 news feeds).</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orge940ee0" class="outline-5">
<h5 id="orge940ee0"><span class="section-number-5">2.21.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-21-2-4">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 60: </span>355 Desin twitter leetcode solution</label><pre class="src src-python" id="org48768a8">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 61: </span>355 Desin twitter leetcode solution-results</label><pre class="src src-none" id="orgf000ac5">
</pre>
</div>
</div>
<div id="outline-container-org8066a46" class="outline-6">
<h6 id="org8066a46"><span class="section-number-6">2.21.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-orgaef49c0" class="outline-6">
<h6 id="orgaef49c0"><span class="section-number-6">2.21.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgd3cca63" class="outline-4">
<h4 id="orgd3cca63"><span class="section-number-4">2.21.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-21-3">
</div>
<div id="outline-container-org6a14406" class="outline-5">
<h5 id="org6a14406"><span class="section-number-5">2.21.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-21-3-1">
<p>
Design, design, design!
</p>

<p>
From this question, we need to again emphasise the importance of thinking ahead and design our program before we write any code.
Jumping into writing code after reading the description can be attracting because that gives us a false feeling of us doing something and make our hands dirty, but when we are doing Leetcode or serious programming, it is paramount that we do more paperwork, more design.
</p>

<p>
The most important thing here is to actually define the question, as medium/hard questions, or easy questions, can contain a lot of information, and we need to process that information and make sure that we understand it by clearly defining it in our own words.
The same not only applies to real world programming as well, but it takes an even more significance in the real world since problems are more vague and complex out there.
</p>

<p>
If we do not think ahead and design well, it is likely that we will write some code, and it will pass some tests and fail some. Then we go back to the code trying to find out what happened, then run it again, then it maybe fail another test, then we fix it again. Essentially we will become a <b>bug</b> ourselves that tries to hit the lightbulb blindly over and over again. We reduce ourselves to a patch that can only fix one case and that may cause another part of the program to fail. Best case, our program becomes a heavy <code>if else</code> monster that does not have clear logic but still runs fine. Worst case, we give up and do not even have the courage to check the solution and try to fix our program, because this is human nature - we do not want to humiliate ourselves, even if the only one that knows we failed is ourselves.
</p>
</div>
</div>
<div id="outline-container-org488885a" class="outline-5">
<h5 id="org488885a"><span class="section-number-5">2.21.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org9366c1d" class="outline-3">
<h3 id="org9366c1d"><span class="section-number-3">2.22.</span> <span class="done DONE">DONE</span> 778 Swim in rising water&#xa0;&#xa0;&#xa0;<span class="tag"><span class="heap">heap</span>&#xa0;<span class="hard">hard</span></span></h3>
<div class="outline-text-3" id="text-2-22">
</div>
<div id="outline-container-org1f14b00" class="outline-4">
<h4 id="org1f14b00"><span class="section-number-4">2.22.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-22-1">
<p>
On an \(N\times N\) grid, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.
</p>

<p>
Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>.
You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>.
You can swim infinite distance in zero time.
Of course, you must stay within the boundaries of the grid during your swim.
</p>

<p>
You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>2 &lt;= N &lt;= 50.</li>
<li>grid[i][j] is a permutation of [0, &#x2026;, N*N - 1].</li>
</ol>
</div>
<div id="outline-container-orgb6a3dc4" class="outline-5">
<h5 id="orgb6a3dc4"><span class="section-number-5">2.22.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-22-1-1">
<pre class="example" id="org6d1b34b">
Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.

Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
 0  1  2  3  4
24 23 22 21  5
12 13 14 15 16
11 17 18 19 20
10  9  8  7  6

We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b2945e" class="outline-4">
<h4 id="org7b2945e"><span class="section-number-4">2.22.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-22-2">
</div>
<div id="outline-container-org49b7214" class="outline-5">
<h5 id="org49b7214"><span class="section-number-5">2.22.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org6192d70" class="outline-5">
<h5 id="org6192d70"><span class="section-number-5">2.22.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-22-2-2">
<p>
We have a loop that controls the time <code>t</code>, which is also the depth of rain.
Then in each iteration, we swim from the <code>last_pos</code> we are at, <code>swim(last_pos)</code>.
<code>last_pos=(0,0)</code> when we are at time 0.
In the <code>swim()</code> function, we choose the direction that is equal or less than <code>t</code>, but that we did not swim before in <code>visited_pos</code>.
Each <code>swim()</code> gives a new <code>last_pos</code>, we check if it is <code>(N-1, N-1)</code>, if so, we just return <code>t</code>.
</p>
</div>
</div>
<div id="outline-container-org890d7d7" class="outline-5">
<h5 id="org890d7d7"><span class="section-number-5">2.22.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-22-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 62: </span>778 Swim in rising water my solution</label><pre class="src src-python" id="org67f5b5c">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">swim_in_water</span>(grid: List[List[<span class="org-builtin">int</span>]]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(grid)
    visited_pos : Set[Tuple[<span class="org-builtin">int</span>]] = <span class="org-builtin">set</span>()

    <span class="org-comment-delimiter"># </span><span class="org-comment">row, col</span>
    <span class="org-variable-name">last_pos</span> = (0, 0)
    visited_pos.add(last_pos)
    <span class="org-keyword">def</span> <span class="org-function-name">avail_poses</span>(last_pos: Tuple[<span class="org-builtin">int</span>]) -&gt; List[Tuple[<span class="org-builtin">int</span>]]:
        <span class="org-variable-name">res</span> = []
        <span class="org-keyword">for</span> row_offset <span class="org-keyword">in</span> [-1, 0, 1]:
            <span class="org-keyword">for</span> col_offset <span class="org-keyword">in</span> [-1, 0, 1]:
                <span class="org-variable-name">row</span> = last_pos[0] + row_offset
                <span class="org-variable-name">col</span> = last_pos[1] + col_offset
                <span class="org-keyword">if</span> 0 &lt;= row &lt; n <span class="org-keyword">and</span> 0 &lt;= col &lt; n <span class="org-keyword">and</span> (row, col) <span class="org-keyword">not</span> <span class="org-keyword">in</span> visited_pos <span class="org-keyword">and</span> grid[row][col] &lt;= t:
                    res.append((row, col))

        <span class="org-keyword">return</span> res

    <span class="org-keyword">def</span> <span class="org-function-name">swim</span>(last_pos: Tuple[<span class="org-builtin">int</span>]) -&gt; Tuple[<span class="org-builtin">int</span>]:
        <span class="org-variable-name">ele</span> = n+1
        <span class="org-variable-name">return_pos</span> = last_pos
        <span class="org-keyword">for</span> pos <span class="org-keyword">in</span> avail_poses(last_pos):
            <span class="org-keyword">if</span> grid[pos[0]][pos[1]] &lt;= ele:
                <span class="org-variable-name">ele</span> = grid[pos[0]][pos[1]]
                <span class="org-variable-name">return_pos</span> = pos
                
        <span class="org-keyword">return</span> return_pos

    <span class="org-keyword">for</span> t <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, n**2):
        <span class="org-keyword">print</span>(t)
        <span class="org-variable-name">last_pos</span> = swim(last_pos)
        visited_pos.add(last_pos)
        <span class="org-keyword">print</span>(last_pos)
        <span class="org-keyword">if</span> last_pos == (n-1, n-1):
            <span class="org-keyword">return</span> t

<span class="org-comment-delimiter">#</span><span class="org-comment">print(swim_in_water([[0,2],[1,3]]))</span>
<span class="org-keyword">print</span>(swim_in_water([[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 63: </span>778 Swim in rising water my solution-results</label><pre class="src src-python" id="org8783949">0
(0, 0)
1
(0, 1)
(0, 1)
2
(0, 2)
(0, 2)
3
(0, 3)
(0, 3)
4
(0, 4)
(0, 4)
5
(1, 4)
(1, 4)
6
(1, 4)
7
(1, 4)
8
(1, 4)
9
(1, 4)
10
(1, 4)
11
(1, 4)
12
(1, 4)
13
(1, 4)
14
(1, 4)
15
(2, 3)
(1, 4)
16
(2, 3)
(2, 4)
(1, 4)
17
(2, 3)
(2, 4)
(1, 4)
18
(2, 3)
(2, 4)
(1, 4)
19
(2, 3)
(2, 4)
(1, 4)
20
(2, 3)
(2, 4)
(1, 4)
21
(1, 3)
(2, 3)
(2, 4)
(1, 4)
22
(1, 3)
(2, 3)
(2, 4)
(1, 4)
23
(1, 3)
(2, 3)
(2, 4)
(1, 4)
24
(1, 3)
(2, 3)
(2, 4)
(1, 4)
<span class="org-constant">None</span>
</pre>
</div>



<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 64: </span>778 Swim in rising water my solution - 2</label><pre class="src src-python" id="org55e4274">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">swim_in_water</span>(grid: List[List[<span class="org-builtin">int</span>]]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(grid)

    <span class="org-comment-delimiter"># </span><span class="org-comment">row, col</span>
    <span class="org-variable-name">last_pos</span> = (0, 0)
    <span class="org-variable-name">visited_poses</span> = <span class="org-builtin">set</span>()
    <span class="org-keyword">def</span> <span class="org-function-name">avail_poses</span>(last_pos: Tuple[<span class="org-builtin">int</span>], cur_t: <span class="org-builtin">int</span>) -&gt; List[Tuple[<span class="org-builtin">int</span>]]:
        <span class="org-variable-name">offsets</span> = (
            (-1, 0),
            (0, 1),
            (1, 0),
            (0, -1)
        )
        <span class="org-variable-name">res</span> = []

        <span class="org-keyword">for</span> row_offset, col_offset <span class="org-keyword">in</span> offsets:
            <span class="org-variable-name">row</span> = last_pos[0] + row_offset
            <span class="org-variable-name">col</span> = last_pos[1] + col_offset
            <span class="org-keyword">if</span> 0 &lt;= row &lt; n <span class="org-keyword">and</span> 0 &lt;= col &lt; n <span class="org-keyword">and</span> (row, col) <span class="org-keyword">not</span> <span class="org-keyword">in</span> visited_poses <span class="org-keyword">and</span> grid[row][col] &lt;= cur_t:
                res.append((row, col))

        <span class="org-keyword">return</span> res

    <span class="org-keyword">def</span> <span class="org-function-name">swim</span>(cur_pos: Tuple[<span class="org-builtin">int</span>], cur_t: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-keyword">if</span> cur_pos == (n-1, n-1):
            <span class="org-keyword">return</span> cur_t

        <span class="org-keyword">while</span> <span class="org-builtin">len</span>(avail_poses(cur_pos, cur_t)) == 0:
            <span class="org-variable-name">cur_t</span> += 1

        <span class="org-keyword">print</span>(cur_pos)
        <span class="org-keyword">print</span>(cur_t)
        <span class="org-keyword">for</span> pos <span class="org-keyword">in</span> avail_poses(cur_pos, cur_t):
            visited_poses.add(pos)
            <span class="org-keyword">return</span> swim(pos, cur_t)

    <span class="org-keyword">return</span> swim(last_pos, 0)

<span class="org-keyword">print</span>(swim_in_water([[0,2],[1,3]]))
<span class="org-comment-delimiter">#</span><span class="org-comment">print(swim_in_water([[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]))</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">(0, 0)
1
(1, 0)
1
(0, 0)
2
(0, 1)
3
3
</pre>
</div>


<p>
Dynamic programming.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 65: </span>778 Swim in rising water my solution - 3</label><pre class="src src-python" id="orgea2dc69">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf

<span class="org-keyword">def</span> <span class="org-function-name">swim_in_water</span>(grid: List[List[<span class="org-builtin">int</span>]]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">adjacent_cells</span>(pos: Tuple[<span class="org-builtin">int</span>]) -&gt; List[Tuple[<span class="org-builtin">int</span>]]:
        <span class="org-variable-name">offsets</span> = (
            (-1, 0),
            (0, 1),
            (1, 0),
            (0, -1)
        )
        <span class="org-variable-name">res</span> = []

        <span class="org-keyword">for</span> row_offset, col_offset <span class="org-keyword">in</span> offsets:
            <span class="org-variable-name">row</span> = pos[0] + row_offset
            <span class="org-variable-name">col</span> = pos[1] + col_offset
            <span class="org-keyword">if</span> 0 &lt;= row &lt; n <span class="org-keyword">and</span> 0 &lt;= col &lt; n:
                res.append((row, col))
        <span class="org-keyword">return</span> res

    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(grid)
    <span class="org-variable-name">min_times</span> = [[inf <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n)] <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n)]
    min_times[0][0] = 0

    <span class="org-keyword">for</span> row <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-keyword">for</span> col <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
            <span class="org-keyword">if</span> (row, col) != (0, 0):
                min_times[row][col] = <span class="org-builtin">min</span>(
                    [<span class="org-builtin">abs</span>(grid[row][col]-grid[adj_row][adj_col]) + min_times[adj_row][adj_col] <span class="org-keyword">for</span> adj_row, adj_col <span class="org-keyword">in</span> adjacent_cells((row, col))]
                )
                
    <span class="org-keyword">return</span> min_times[n-1][n-1]

<span class="org-comment-delimiter">#</span><span class="org-comment">print(swim_in_water([[0,2],[1,3]]))</span>
<span class="org-keyword">print</span>(swim_in_water([[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[[0, 1, 2, 3, 4], [24, 23, 22, 21, 5], [36, 33, 30, 27, 16], [37, 37, 34, 31, 20], [38, 39, 40, 41, 34]]
</pre>
</div>

<p>
Dijkstra's algorithm.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 66: </span>778 Swim in rising water my solution - 4</label><pre class="src src-python" id="orgfa3ecdf">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf

<span class="org-keyword">def</span> <span class="org-function-name">swim_in_water</span>(grid: List[List[<span class="org-builtin">int</span>]]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">adjacent_cells</span>(pos: Tuple[<span class="org-builtin">int</span>]) -&gt; List[Tuple[<span class="org-builtin">int</span>]]:
        <span class="org-variable-name">offsets</span> = (
            (-1, 0),
            (0, 1),
            (1, 0),
            (0, -1)
        )
        <span class="org-variable-name">res</span> = []

        <span class="org-keyword">for</span> row_offset, col_offset <span class="org-keyword">in</span> offsets:
            <span class="org-variable-name">row</span> = pos[0] + row_offset
            <span class="org-variable-name">col</span> = pos[1] + col_offset
            <span class="org-keyword">if</span> 0 &lt;= row &lt; n <span class="org-keyword">and</span> 0 &lt;= col &lt; n:
                res.append((row, col))
        <span class="org-keyword">return</span> res

    <span class="org-keyword">def</span> <span class="org-function-name">min_distance</span>(pos, dist):
        <span class="org-variable-name">min_dist</span> = inf
        <span class="org-variable-name">min_index</span> = <span class="org-constant">None</span>
        <span class="org-keyword">for</span> row, col <span class="org-keyword">in</span> adjacent_cells(pos):
            <span class="org-variable-name">dist</span> = <span class="org-builtin">abs</span>(grid[row][col] - grid[pos[0]][pos[1]])
            <span class="org-keyword">if</span>  (row, col) <span class="org-keyword">not</span> <span class="org-keyword">in</span> dist <span class="org-keyword">and</span> dist &lt; min_dist:
                <span class="org-variable-name">min_dist</span> = dist
                <span class="org-variable-name">min_index</span> = (row, col)

        <span class="org-keyword">return</span> min_index
            

    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(grid)
    <span class="org-variable-name">dist</span> = <span class="org-builtin">dict</span>()

    <span class="org-comment-delimiter"># </span><span class="org-comment">The set of visited vertices</span>
    <span class="org-variable-name">visited</span> = <span class="org-builtin">set</span>()
    <span class="org-comment-delimiter"># </span><span class="org-comment">The set of unvisited vertices</span>
    <span class="org-variable-name">unvisited</span> = <span class="org-builtin">set</span>()

    <span class="org-comment-delimiter"># </span><span class="org-comment">set all other distances to infinity</span>
    <span class="org-keyword">for</span> row <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
        <span class="org-keyword">for</span> col <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
            <span class="org-variable-name">dist</span>[(row, col)] = inf
            unvisited.add((row, col))

    <span class="org-variable-name">dist</span> = {(0, 0): 0}

    <span class="org-keyword">while</span> <span class="org-builtin">len</span>(unvisited) != 0:


    <span class="org-keyword">return</span> dist[(n-1, n-1)]


<span class="org-comment-delimiter">#</span><span class="org-comment">print(swim_in_water([[0,2],[1,3]]))</span>
<span class="org-keyword">print</span>(swim_in_water([[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]))
</pre>
</div>
</div>
<div id="outline-container-org31ccb4d" class="outline-6">
<h6 id="org31ccb4d"><span class="section-number-6">2.22.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-22-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org76cf6d1"></a>Time complexity:<br></li>

<li><a id="orgf5d269e"></a>Space complexity:<br></li>
</ol>
</div>
</div>

<div id="outline-container-778 Leetcode" class="outline-5">
<h5 id="778 Leetcode"><span class="section-number-5">2.22.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-778 Leetcode">
<p>
We use <a href="#org57c5ed9">4.3</a>.
</p>

<p>
Given a grid like below:
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">4</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Starting from <code>grid[0][0]</code>, we have two adjacent cells, we add them to the heap
because we can naively reach them starting from <code>grid[0][0]</code>.
</p>

<p>
By definition, we want to choose the cell with the minimum elevation in a list of possible choices,
so we pop from the heap, and get <code>grid[0][1]</code>, <code>2</code>.
</p>

<p>
Then we get its adjacent cells, <code>grid[0][2]</code>, <code>5</code> and <code>grid[1][1]</code>, <code>7</code>.
We add these two to the heap.
</p>

<p>
Now, it is obvious to the naked eye that <code>3&lt;5&lt;7</code>, so at this moment we have to choose the <code>grid[1][0]</code>, <code>3</code>, path.
Again, we simply pop from the heap to do this. After this operation, our heap now has two elements left, <code>grid[0][2]</code>, <code>5</code>, and <code>grid[1][1]</code>, <code>7</code>.
</p>

<p>
We then again check the adjacent cells of <code>grid[1][0]</code>, <code>3</code>, and add them to the heap.
Now in the heap we have four elements, <code>grid[0][2]</code>, <code>5</code>, <code>grid[1][1]</code>, <code>7</code>, <code>grid[1][1]</code>, <code>7</code>, <code>grid[2][0]</code>, <code>8</code>
</p>

<p>
We continue this loop until we reach <code>grid[n-1][n-1]</code>.
</p>

<p>
Intuitively speaking, all elements in the heap have been <b>discovered</b> by us before, meaning that there is a valid path from the start to it. 
For example, when we are at <code>grid[0][1]</code>, <code>2</code>, and we find that <code>5</code> and <code>7</code> are larger than another option <code>3</code>, then there must be a way from <code>grid[0][0]</code> for us to <i>swim</i> to <code>grid[1][0]</code>, <code>3</code>, in no time.
When we are at <code>grid[1][0]</code>, <code>3</code>, and find that <code>7</code> and <code>8</code> are larger than another option <code>5</code>, we can <i>swim</i> to <code>grid[0][2]</code>, <code>5</code>, in no time.
</p>

<p>
The process of <b>finding and getting (swimming to) the smallest</b> option/heading/cell/elevation is done by the priority queue automatically.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 67: </span>778 Swim in rising water leetcode solution</label><pre class="src src-python" id="orgc3ed5f4">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">import</span> heapq

<span class="org-keyword">def</span> <span class="org-function-name">swim_in_water</span>(grid: List[List[<span class="org-builtin">int</span>]]) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">visited</span>, <span class="org-variable-name">heap</span> = <span class="org-builtin">set</span>(), [(grid[0][0], 0, 0)]
    <span class="org-variable-name">time</span>, <span class="org-variable-name">n</span> = 0, <span class="org-builtin">len</span>(grid)

    <span class="org-comment-delimiter"># </span><span class="org-comment">The idea to use heap is that:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">1. It keeps a list of possible cells to take, and</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">2. The cell with the minimum cost/elevation is stored at the top</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">3. At the start of every iteration, every cell in the heap has been seen before,</span>
    <span class="org-comment-delimiter">#    </span><span class="org-comment">meaning that there is at least one path from (0, 0) to that cell</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">Intuitively, we always want to choose the cell with the minimum elevation.</span>
    <span class="org-comment-delimiter"># </span>
    <span class="org-keyword">while</span> heap:
        <span class="org-variable-name">cur</span>, <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span> = heapq.heappop(heap)
        visited.add((x, y))
        <span class="org-variable-name">time</span> = <span class="org-builtin">max</span>(time, cur)

        <span class="org-keyword">if</span> x == y == n-1:
            <span class="org-keyword">return</span> time
        <span class="org-keyword">for</span> i, j <span class="org-keyword">in</span> [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:
            <span class="org-keyword">if</span> 0&lt;=i&lt;=n-1 <span class="org-keyword">and</span> 0&lt;=j&lt;=n-1 <span class="org-keyword">and</span> (i, j) <span class="org-keyword">not</span> <span class="org-keyword">in</span> visited:
                heapq.heappush(heap, (grid[i][j], i, j))

        <span class="org-keyword">print</span>(cur)
        <span class="org-keyword">print</span>(heap)

    <span class="org-keyword">return</span> -1
<span class="org-keyword">print</span>(swim_in_water([[8,2, 7], [3,4, 6], [1, 5, 0]]))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 68: </span>778 Swim in rising water leetcode solution-results</label><pre class="src src-python" id="org1b6cf3f">8
[(2, 0, 1), (3, 1, 0)]
2
[(3, 1, 0), (4, 1, 1), (7, 0, 2)]
3
[(1, 2, 0), (4, 1, 1), (4, 1, 1), (7, 0, 2)]
1
[(4, 1, 1), (4, 1, 1), (7, 0, 2), (5, 2, 1)]
4
[(4, 1, 1), (5, 2, 1), (7, 0, 2), (5, 2, 1), (6, 1, 2)]
4
[(5, 2, 1), (5, 2, 1), (6, 1, 2), (6, 1, 2), (5, 2, 1), (7, 0, 2)]
5
[(0, 2, 2), (5, 2, 1), (5, 2, 1), (6, 1, 2), (7, 0, 2), (6, 1, 2)]
8
</pre>
</div>
</div>
<div id="outline-container-orgd1c4a75" class="outline-6">
<h6 id="orgd1c4a75"><span class="section-number-6">2.22.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-22-2-4-1">
<p>
\(O(n^2\lg n)\), \(n\) is the number of rows of the grid. The <code>while</code> loop takes \(O(n^2)\) time. Inside it, the <code>heapq.heappush</code> takes
\(O(\lg n)\) time.
</p>
</div>
</div>
<div id="outline-container-org7a53432" class="outline-6">
<h6 id="org7a53432"><span class="section-number-6">2.22.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-22-2-4-2">
<p>
\(O(n)\), <code>visited</code> and <code>heap</code>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org86278ee" class="outline-4">
<h4 id="org86278ee"><span class="section-number-4">2.22.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-22-3">
</div>
<div id="outline-container-orgf25fa54" class="outline-5">
<h5 id="orgf25fa54"><span class="section-number-5">2.22.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-22-3-1">
<p>
See <a href="#778 Leetcode">2.22.2.4</a>.
</p>
</div>
</div>
<div id="outline-container-orgdb6082c" class="outline-5">
<h5 id="orgdb6082c"><span class="section-number-5">2.22.3.2.</span> Related problems</h5>
<div class="outline-text-5" id="text-2-22-3-2">
<p>
<a href="#org57c5ed9">4.3</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org91890de" class="outline-3">
<h3 id="org91890de"><span class="section-number-3">2.23.</span> <span class="done DONE">DONE</span> 1022 Sum of root to leaf binary numbers&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tree">tree</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-23">
</div>
<div id="outline-container-org69ae72d" class="outline-4">
<h4 id="org69ae72d"><span class="section-number-4">2.23.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-23-1">
<p>
Given a binary tree, each node has value <code>0</code> or <code>1</code>.
Each root-to-leaf path represents a binary number starting with the most significant bit.
For example, if the path is <code>0-&gt;1-&gt;1-&gt;0-&gt;1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.
</p>

<p>
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.
</p>

<p>
Return the sum of these numbers.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>The number of nodes in the tree is between 1 and 1000.</li>
<li>node.val is 0 or 1.</li>
<li>The answer will not exceed 2<sup>31</sup> - 1.</li>
</ol>
</div>
<div id="outline-container-orgad6dd85" class="outline-5">
<h5 id="orgad6dd85"><span class="section-number-5">2.23.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-23-1-1">
<pre class="example" id="org7ce5101">
Input: [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
</pre>
</div>
</div>
</div>

<div id="outline-container-org34048c5" class="outline-4">
<h4 id="org34048c5"><span class="section-number-4">2.23.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-23-2">
</div>
<div id="outline-container-org56d865a" class="outline-5">
<h5 id="org56d865a"><span class="section-number-5">2.23.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org3aa2a21" class="outline-5">
<h5 id="org3aa2a21"><span class="section-number-5">2.23.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-23-2-2">
<p>
We try to use generators to solve the calculation part of the problem.
For traversing the tree, we use pre-order traversal.
</p>
</div>
</div>
<div id="outline-container-org4075fca" class="outline-5">
<h5 id="org4075fca"><span class="section-number-5">2.23.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-23-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 69: </span>1022 Sum of root to leaf binary numbers my solution</label><pre class="src src-python" id="org06cd365">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">class</span> <span class="org-type">TreeNode</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, val=0, left=<span class="org-constant">None</span>, right=<span class="org-constant">None</span>):
        <span class="org-keyword">self</span>.val = val
        <span class="org-keyword">self</span>.left = left
        <span class="org-keyword">self</span>.right = right


<span class="org-keyword">def</span> <span class="org-function-name">calculator</span>():
    <span class="org-variable-name">total</span> = 0
    <span class="org-variable-name">bit</span> = <span class="org-constant">None</span>
    <span class="org-variable-name">num</span> = <span class="org-string">""</span> <span class="org-comment-delimiter"># </span><span class="org-comment">every path uses the same num in the calculator generator, so this is messed up</span>

    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">bit</span> = <span class="org-keyword">yield</span>

        <span class="org-keyword">if</span> bit <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">We must terminate the coroutine normally</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">to return a value.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">If we do try...except GeneratorExit, we will not be able to return a value later</span>
            <span class="org-keyword">break</span>
        <span class="org-keyword">elif</span> bit == <span class="org-string">"leaf"</span>:
            <span class="org-variable-name">total</span> += <span class="org-builtin">int</span>(num, 2)
            <span class="org-variable-name">num</span> = num[:-1]
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">num</span> = num + <span class="org-builtin">str</span>(bit)

    <span class="org-keyword">return</span> total

<span class="org-keyword">def</span> <span class="org-function-name">dele_gen</span>():
    <span class="org-keyword">global</span> results
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">results</span> = <span class="org-keyword">yield</span> <span class="org-keyword">from</span> calculator()


<span class="org-variable-name">results</span> = 0
<span class="org-variable-name">calc</span> = dele_gen()
<span class="org-builtin">next</span>(calc)
<span class="org-keyword">def</span> <span class="org-function-name">traverse</span>(node, calc):
    <span class="org-keyword">if</span> node:
        calc.send(node.val)
        <span class="org-keyword">if</span> node.left <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">or</span> node.right <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            calc.send(<span class="org-string">"leaf"</span>)
        <span class="org-keyword">else</span>:
            traverse(node.left, calc)
            traverse(node.right, calc)
    <span class="org-keyword">else</span>:
        calc.send(<span class="org-string">""</span>)
        
<span class="org-variable-name">l_1</span> = TreeNode(0)
<span class="org-variable-name">r_0</span> = TreeNode(1)
<span class="org-variable-name">l</span> = TreeNode(0, l_1, r_0)
<span class="org-variable-name">r</span> = TreeNode(1)
<span class="org-variable-name">root</span> = TreeNode(1, l, r)
traverse(root, calc)
calc.send(<span class="org-constant">None</span>)
<span class="org-keyword">print</span>(results)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 70: </span>1022 Sum of root to leaf binary numbers my solution-results</label><pre class="src src-python" id="orga576f74">11
</pre>
</div>
</div>
<div id="outline-container-org60fb808" class="outline-6">
<h6 id="org60fb808"><span class="section-number-6">2.23.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-23-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org3994b44"></a>Time complexity:<br></li>

<li><a id="orgca552fe"></a>Space complexity:<br></li>
</ol>
</div>
</div>

<div id="outline-container-org54c9f6e" class="outline-5">
<h5 id="org54c9f6e"><span class="section-number-5">2.23.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-23-2-4">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 71: </span>1022 Sum of root to leaf binary numbers leetcode solution</label><pre class="src src-python" id="orgc32c44a">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-keyword">class</span> <span class="org-type">TreeNode</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, val=0, left=<span class="org-constant">None</span>, right=<span class="org-constant">None</span>):
        <span class="org-keyword">self</span>.val = val
        <span class="org-keyword">self</span>.left = left
        <span class="org-keyword">self</span>.right = right

<span class="org-keyword">def</span> <span class="org-function-name">sum_root_to_leaf</span>(root) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> root:
        <span class="org-keyword">return</span> 0

    <span class="org-variable-name">res</span> = []

    <span class="org-keyword">def</span> <span class="org-function-name">helper</span>(node, path):
        <span class="org-keyword">if</span> node.left <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> node.right <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            res.append(path + <span class="org-builtin">str</span>(node.val))
            <span class="org-keyword">return</span>
        
        <span class="org-keyword">if</span> node.left:
            helper(node.left, path + <span class="org-builtin">str</span>(node.val))

        <span class="org-keyword">if</span> node.right:
            helper(node.right, path+<span class="org-builtin">str</span>(node.val))


    helper(root, <span class="org-string">"0b"</span>)
    <span class="org-keyword">return</span> <span class="org-builtin">sum</span>([<span class="org-builtin">int</span>(p, 2) <span class="org-keyword">for</span> p <span class="org-keyword">in</span> res])
<span class="org-variable-name">l_1</span> = TreeNode(0)
<span class="org-variable-name">r_0</span> = TreeNode(1)
<span class="org-variable-name">l</span> = TreeNode(0, l_1, r_0)
<span class="org-variable-name">r</span> = TreeNode(1)
<span class="org-variable-name">root</span> = TreeNode(1, l, r)
<span class="org-keyword">print</span>(sum_root_to_leaf(root))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 72: </span>1022 Sum of root to leaf binary numbers leetcode solution-results</label><pre class="src src-python" id="org87e582e">12
</pre>
</div>
</div>
<div id="outline-container-orge95efca" class="outline-6">
<h6 id="orge95efca"><span class="section-number-6">2.23.2.4.1.</span> Time complexity:</h6>
<div class="outline-text-6" id="text-2-23-2-4-1">
<p>
\(O(n)\), where <code>n</code> is the number of nodes, as this algorithm visits all nodes in the tree.
</p>
</div>
</div>
<div id="outline-container-orgc79975c" class="outline-6">
<h6 id="orgc79975c"><span class="section-number-6">2.23.2.4.2.</span> Space complexity:</h6>
<div class="outline-text-6" id="text-2-23-2-4-2">
<p>
Assuming full binary tree, \(O(n\log(n))\), we need to have \(O(n)\) <code>paths</code> (number of leaves of the tree), each having the length of \(\log(n)\) (height of the tree).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1983e8f" class="outline-4">
<h4 id="org1983e8f"><span class="section-number-4">2.23.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-23-3">
</div>
<div id="outline-container-org612b143" class="outline-5">
<h5 id="org612b143"><span class="section-number-5">2.23.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-23-3-1">
<p>
A key problem in my solution is that I have no way of creating path copies easily.
</p>

<p>
Initially I thought that it was a good idea to use a generator responsible for calculating the total as this is somewhat similar to calculating a running average problem. 
Then the problem came when the variable <code>num</code> could only hold <b>one path</b> and the generator had no easy way to keep track of the paths that corresponds to nodes. Therefore, when it added the <code>num</code> for the left most leaf to the total, it could not determine which path to take next.
</p>

<p>
The only way to do it is to backtrack <code>num</code> by removing the bits that correspond to the leaf that has been visited and its parent, grandparent, great-grandparent&#x2026; that has no other children. This causes a lot of trouble as every node references this single variable <code>num</code>, and there are many states to check.
</p>

<p>
The code from Leetcode discussion solves this problem by copying the current path at each node, though this is done implicitly, as strings are copied implicitly.
Therefore, every node has their own copy the the current path, and they can safely modify the path (<code>path+str(node.val)</code>) without affecting other nodes.
</p>
</div>
</div>
<div id="outline-container-orgeee50b3" class="outline-5">
<h5 id="orgeee50b3"><span class="section-number-5">2.23.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-org49db84d" class="outline-3">
<h3 id="org49db84d"><span class="section-number-3">2.24.</span> <span class="done DONE">DONE</span> 1207 Unique number of occurrences&#xa0;&#xa0;&#xa0;<span class="tag"><span class="hash_table">hash_table</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-24">
</div>
<div id="outline-container-org4ff81de" class="outline-4">
<h4 id="org4ff81de"><span class="section-number-4">2.24.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-24-1">
<p>
Given an array of integers <code>arr</code>, write a function that returns <code>true</code> iff the number of occurrences of each value in the array is unique.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>1 &lt;= arr.length &lt;= 1000</li>
<li>-1000 &lt;= arr[i] &lt;= 1000</li>
</ol>
</div>
<div id="outline-container-orgae31887" class="outline-5">
<h5 id="orgae31887"><span class="section-number-5">2.24.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-24-1-1">
<pre class="example" id="org46cd54b">
Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

Input: arr = [1,2]
Output: false

Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true
</pre>
</div>
</div>
</div>

<div id="outline-container-org9232205" class="outline-4">
<h4 id="org9232205"><span class="section-number-4">2.24.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-24-2">
</div>
<div id="outline-container-org8c7a42f" class="outline-5">
<h5 id="org8c7a42f"><span class="section-number-5">2.24.2.1.</span> Understanding the problem</h5>
<div class="outline-text-5" id="text-2-24-2-1">
<p>
The problem:
</p>
<ol class="org-ol">
<li>gives an array of integers that</li>
<li>could be negative, 0, or positive.</li>
<li>wants us to count the number of occurrences (<code>occur</code>) of each value, and</li>
<li>return true if <code>occur</code> of each integer is different.</li>
</ol>
</div>
</div>
<div id="outline-container-org6db923f" class="outline-5">
<h5 id="org6db923f"><span class="section-number-5">2.24.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-24-2-2">
<p>
We scan the integer array, and add one to the counter (<code>occur</code>) map of each value we met.
We then scan the counter map to see if there is more than one unique numbers.
</p>
</div>
</div>
<div id="outline-container-orgef0b272" class="outline-5">
<h5 id="orgef0b272"><span class="section-number-5">2.24.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-24-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 73: </span>1207 Unique number of occurrences my solution</label><pre class="src src-python" id="org5bc5569">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;


<span class="org-keyword">def</span> <span class="org-function-name">unique_occurrences</span>(arr: List[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">bool</span>:
    <span class="org-variable-name">occurs</span> = {}
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> arr:
        <span class="org-variable-name">occurs</span>[i] = occurs.get(i, 0) + 1

        
    <span class="org-variable-name">uniques</span> = <span class="org-builtin">set</span>(occurs.values())
    <span class="org-keyword">return</span> <span class="org-builtin">len</span>(uniques) == <span class="org-builtin">len</span>(occurs.values())

<span class="org-variable-name">arr</span> = [1,2,2,1,1,3]
<span class="org-variable-name">arr</span> = [2,2,1,1,3]
<span class="org-keyword">print</span>(unique_occurrences(arr))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 74: </span>1207 Unique number of occurrences my solution-results</label><pre class="src src-python" id="org1e88eb8"><span class="org-constant">False</span>
</pre>
</div>
</div>
<div id="outline-container-org800a40f" class="outline-6">
<h6 id="org800a40f"><span class="section-number-6">2.24.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-24-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org7a58db9"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-24-2-3-1-1">
<p>
\(O(n)\), where \(n\) is the number of elements in the array.
</p>
</div>
</li>
<li><a id="orga2b6e03"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-24-2-3-1-2">
<p>
\(O(n)\).
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org6c7bb22" class="outline-5">
<h5 id="org6c7bb22"><span class="section-number-5">2.24.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-24-2-4">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 75: </span>1207 Unique number of occurrences leetcode solution</label><pre class="src src-python" id="org7ca1b77">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 76: </span>1207 Unique number of occurrences leetcode solution-results</label><pre class="src src-none" id="org8c81779">
</pre>
</div>
</div>
<div id="outline-container-org8b303c1" class="outline-6">
<h6 id="org8b303c1"><span class="section-number-6">2.24.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org6d95f96" class="outline-6">
<h6 id="org6d95f96"><span class="section-number-6">2.24.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org33bf056" class="outline-4">
<h4 id="org33bf056"><span class="section-number-4">2.24.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-24-3">
</div>
<div id="outline-container-orgd17cc7e" class="outline-5">
<h5 id="orgd17cc7e"><span class="section-number-5">2.24.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-24-3-1">
<p>
This is an easy question. The <i>hard</i> part of this question is actually understanding the description clearly and quickly. This is why I suddenly decided to add a <i>Understanding the problem</i> heading. 
</p>

<p>
It's actually amazing that after so many questions and problems that I have solved, I put this heading in so late. Yes the importance of understanding the question, or figuring out the definition of the terms used in the question, has been known to me for quite some time, but somehow I just did not give credits where it's due. It's almost like I'm unconsciously supressing the known idea that understanding the problem clearly and quickly is crucial to solving the problem. 
</p>

<p>
I want to take this opportunity to write it down explicitly that the first thing we need to do in any coding (or anything really) is to <b>come to terms with the author</b> (<i>How to read a book</i>). We must first understand what the words mean before we understand what the author of the problem is saying by giving us those words. Again, this is an extremly simple and important but often ignored rule.
</p>
</div>
</div>
<div id="outline-container-org98e6601" class="outline-5">
<h5 id="org98e6601"><span class="section-number-5">2.24.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-org828736b" class="outline-3">
<h3 id="org828736b"><span class="section-number-3">2.25.</span> <span class="todo TODO">TODO</span> 706 Design HashMap&#xa0;&#xa0;&#xa0;<span class="tag"><span class="hash_table">hash_table</span>&#xa0;<span class="easy">easy</span></span></h3>
<div class="outline-text-3" id="text-2-25">
</div>
<div id="outline-container-org1900d37" class="outline-4">
<h4 id="org1900d37"><span class="section-number-4">2.25.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-25-1">
<p>
Design a HashMap without using any built-in hash table libraries.
</p>

<p>
To be specific, your design should include these functions:
</p>
<ul class="org-ul">
<li><code>put(key, value)</code>: insert a <code>(key, value)</code> pair into the HashMap. If the value already exists in the HashMap, update the value.</li>
<li><code>get(key)</code>: returns the value to which the specified key is mapped, or <code>-1</code> if this map contains no mapping for the key.</li>
<li><code>remove(key)</code>: remove the mapping for the value key if this map contains the mapping for the key.</li>
</ul>


<p>
Constraints:
</p>
<ol class="org-ol">
<li>All keys and values will be in the range of [0, 1000000].</li>
<li>The number of operations will be in the range of [1, 10000].</li>
<li>Please do not use the built-in HashMap library.</li>
</ol>
</div>
<div id="outline-container-org5418b8a" class="outline-5">
<h5 id="org5418b8a"><span class="section-number-5">2.25.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-25-1-1">
<pre class="example" id="org4c1d621">
MyHashMap hashMap = new MyHashMap();
hashMap.put(1, 1);          
hashMap.put(2, 2);         
hashMap.get(1);            // returns 1
hashMap.get(3);            // returns -1 (not found)
hashMap.put(2, 1);          // update the existing value
hashMap.get(2);            // returns 1 
hashMap.remove(2);          // remove the mapping for 2
hashMap.get(2);            // returns -1 (not found) 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc3dcbb5" class="outline-4">
<h4 id="orgc3dcbb5"><span class="section-number-4">2.25.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-25-2">
</div>
<div id="outline-container-orgfac6c99" class="outline-5">
<h5 id="orgfac6c99"><span class="section-number-5">2.25.2.1.</span> Understanding the problem</h5>
<div class="outline-text-5" id="text-2-25-2-1">
<p>
The <code>remove()</code> method, though not mentioned, should be idempotent.
</p>

<p>
The code template also gives more information on requirements.
The <code>key</code> is an integer and <code>value</code> will always be non-negative.
</p>

<p>
Because the number of operations will be in the range less than <code>10000</code>, this can be used as
the length of our array backing up the map, assuming that all the operations were <code>put()</code>.
</p>
</div>
</div>
<div id="outline-container-orga571237" class="outline-5">
<h5 id="orga571237"><span class="section-number-5">2.25.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-25-2-2">
<p>
We need to find a proper hash function.
</p>

<p>
For the hash function, we simply divide the <code>key</code> by <code>100</code>. We can use doubly linked list for handling collision.
</p>
</div>
</div>
<div id="outline-container-orgaf9e3e9" class="outline-5">
<h5 id="orgaf9e3e9"><span class="section-number-5">2.25.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-25-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 77: </span>706 Design HashMap my solution</label><pre class="src src-python" id="orgf4c82b8">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;
<span class="org-keyword">class</span> <span class="org-type">MyHashMap</span>:
    <span class="org-keyword">class</span> <span class="org-type">Node</span>:

        <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, val: <span class="org-builtin">int</span>, key: <span class="org-builtin">int</span>, parent: <span class="org-string">'Node'</span>=<span class="org-constant">None</span>, child: <span class="org-string">'Node'</span>=<span class="org-constant">None</span>):
            <span class="org-keyword">self</span>._val = val
            <span class="org-keyword">self</span>._key = key
            <span class="org-keyword">self</span>._parent = parent
            <span class="org-keyword">self</span>._child = child

        @<span class="org-builtin">property</span>
        <span class="org-keyword">def</span> <span class="org-function-name">val</span>(<span class="org-keyword">self</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._val
        <span class="org-type">@val.setter</span>
        <span class="org-keyword">def</span> <span class="org-function-name">val</span>(<span class="org-keyword">self</span>, val):
            <span class="org-keyword">self</span>._val = val

        @<span class="org-builtin">property</span>
        <span class="org-keyword">def</span> <span class="org-function-name">key</span>(<span class="org-keyword">self</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._key

        <span class="org-type">@key.setter</span>
        <span class="org-keyword">def</span> <span class="org-function-name">key</span>(<span class="org-keyword">self</span>, key):
            <span class="org-keyword">self</span>._key = key

        @<span class="org-builtin">property</span>
        <span class="org-keyword">def</span> <span class="org-function-name">child</span>(<span class="org-keyword">self</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._child

        <span class="org-type">@child.setter</span>
        <span class="org-keyword">def</span> <span class="org-function-name">child</span>(<span class="org-keyword">self</span>, child: <span class="org-string">'Node'</span>):
            <span class="org-keyword">self</span>._child = child

        @<span class="org-builtin">property</span>
        <span class="org-keyword">def</span> <span class="org-function-name">parent</span>(<span class="org-keyword">self</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._parent

        <span class="org-type">@parent.setter</span>
        <span class="org-keyword">def</span> <span class="org-function-name">parent</span>(<span class="org-keyword">self</span>, parent: <span class="org-string">'Node'</span>):
            <span class="org-keyword">self</span>._parent = parent
            

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">gen_nodes</span>(root: <span class="org-string">'Node'</span>):
        <span class="org-variable-name">node</span> = root
        <span class="org-keyword">while</span> node:
            <span class="org-keyword">yield</span> node
            <span class="org-variable-name">node</span> = node.child

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Initialize your data structure here.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">self</span>.arr = [<span class="org-keyword">self</span>.Node(-1, -1) <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(10000)]
        
    <span class="org-keyword">def</span> <span class="org-function-name">_get_nodes</span>(<span class="org-keyword">self</span>, key: <span class="org-builtin">int</span>):

        <span class="org-variable-name">hash_value</span> = <span class="org-keyword">self</span>._hash_func(key)
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.gen_nodes(<span class="org-keyword">self</span>.arr[hash_value])

    <span class="org-keyword">def</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, key: <span class="org-builtin">int</span>, value: <span class="org-builtin">int</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        value will always be non-negative.</span>
<span class="org-doc">        """</span>

        <span class="org-variable-name">nodes</span> = <span class="org-keyword">self</span>._get_nodes(key)
        <span class="org-keyword">for</span> node <span class="org-keyword">in</span> nodes:
            <span class="org-keyword">if</span> node.key == key:
                <span class="org-variable-name">node.val</span> = value
                <span class="org-keyword">break</span>
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">node.child</span> = <span class="org-keyword">self</span>.Node(value, key, node)

    <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, key: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">nodes</span> = <span class="org-keyword">self</span>._get_nodes(key)
        <span class="org-keyword">for</span> node <span class="org-keyword">in</span> nodes:
            <span class="org-keyword">if</span> node.key == key:
                <span class="org-keyword">return</span> node.val

        <span class="org-keyword">return</span> -1
    

    <span class="org-keyword">def</span> <span class="org-function-name">remove</span>(<span class="org-keyword">self</span>, key: <span class="org-builtin">int</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Removes the mapping of the specified value key if this map contains a mapping for the key</span>
<span class="org-doc">        """</span>
        
        <span class="org-variable-name">nodes</span> = <span class="org-keyword">self</span>._get_nodes(key)
        <span class="org-keyword">for</span> node <span class="org-keyword">in</span> nodes:
            <span class="org-keyword">if</span> node.key == key:
                <span class="org-keyword">if</span> node.child:
                    <span class="org-variable-name">node.child.parent</span> = node.parent
                    
                <span class="org-variable-name">node.parent.child</span> = node.child

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">_hash_func</span>(key: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Hashes key</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">return</span> key // 100

<span class="org-variable-name">obj</span> = MyHashMap()
obj.put(100, 123)
<span class="org-keyword">print</span>(obj.get(100))
obj.put(101, 124)
obj.put(101, 1024)
<span class="org-keyword">print</span>(obj.get(101))
obj.put(102, 125)
<span class="org-keyword">print</span>(obj.get(102))
obj.remove(102)
<span class="org-keyword">print</span>(obj.get(102))
<span class="org-keyword">print</span>(obj.get(101))
<span class="org-keyword">print</span>(obj.get(103))
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 78: </span>706 Design HashMap my solution-results</label><pre class="src src-python" id="org8ac422a">123
1024
125
-1
1024
-1
</pre>
</div>
</div>
<div id="outline-container-org2dfc488" class="outline-6">
<h6 id="org2dfc488"><span class="section-number-6">2.25.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-25-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org13a3462"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-25-2-3-1-1">
<p>
\(O(1)\) average.
</p>
</div>
</li>
<li><a id="orgc287cfc"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-25-2-3-1-2">
<p>
\(O(1)\) given at maximum 10000 operations.
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org2a495be" class="outline-5">
<h5 id="org2a495be"><span class="section-number-5">2.25.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-25-2-4">
<p>
Not available.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 79: </span>706 Design HashMap leetcode solution</label><pre class="src src-python" id="org795a740">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 80: </span>706 Design HashMap leetcode solution-results</label><pre class="src src-none" id="org3ecc8e7">
</pre>
</div>
</div>
<div id="outline-container-orga6ee00e" class="outline-6">
<h6 id="orga6ee00e"><span class="section-number-6">2.25.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-orgf85b71e" class="outline-6">
<h6 id="orgf85b71e"><span class="section-number-6">2.25.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgd2155fc" class="outline-4">
<h4 id="orgd2155fc"><span class="section-number-4">2.25.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-25-3">
</div>
<div id="outline-container-orgff38751" class="outline-5">
<h5 id="orgff38751"><span class="section-number-5">2.25.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-25-3-1">
<p>
Coming up with the solution algorithm conceptually is not hard as this is well-documented in CLRS.
</p>

<p>
The hard part comes at the actual coding. Basically, I encountered the following issues:
</p>
<ol class="org-ol">
<li>Properly use reference to inner class</li>
<li>Properly reference the class itself when setting types for arguments</li>
<li>Properly use <code>@property</code> decorator and <code>property.setter</code> as I did not use them often.</li>
</ol>

<p>
Besides those issues, I was also sceptical if the following code would work.
That is to say, if I still have reference to the last <code>node</code> when I break out of the loop.
</p>

<p>
The answer is yes, since <code>node</code> is shadowed in the <code>for</code> loop. Therefore, if we break out of the loop or the loop finishes, node still points to the last object it got in the loop.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">node</span> = <span class="org-constant">None</span>
<span class="org-keyword">for</span> node <span class="org-keyword">in</span> nodes:
    <span class="org-keyword">if</span> node.key == key:
        <span class="org-variable-name">node.val</span> = value
        <span class="org-keyword">break</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">this is a slight modification of my solution</span>
<span class="org-variable-name">node.child</span> = <span class="org-keyword">self</span>.Node(value, key, node)
</pre>
</div>
</div>
</div>
<div id="outline-container-orga50a664" class="outline-5">
<h5 id="orga50a664"><span class="section-number-5">2.25.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-orga8aa3f4" class="outline-3">
<h3 id="orga8aa3f4"><span class="section-number-3">2.26.</span> <span class="todo TODO">TODO</span> 208 Implementing Trie</h3>
<div class="outline-text-3" id="text-2-26">
</div>
<div id="outline-container-org7b779f0" class="outline-4">
<h4 id="org7b779f0"><span class="section-number-4">2.26.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-26-1">
<p>
Implement a Trie with <code>insert</code>, <code>search</code> and <code>startwith</code>.
</p>

<p>
Constraints:
</p>
<ol class="org-ol">
<li>You may assume that all inputs are consist of lowercase letters a-z.</li>
<li>All inputs are guaranteed to be non-empty strings.</li>
</ol>
</div>
<div id="outline-container-org6fed348" class="outline-5">
<h5 id="org6fed348"><span class="section-number-5">2.26.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-26-1-1">
<pre class="example" id="org3b57cc1">
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");   
trie.search("app");     // returns true
</pre>
</div>
</div>
</div>

<div id="outline-container-orga247c2b" class="outline-4">
<h4 id="orga247c2b"><span class="section-number-4">2.26.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-26-2">
</div>
<div id="outline-container-org3430d49" class="outline-5">
<h5 id="org3430d49"><span class="section-number-5">2.26.2.1.</span> Understanding the problem</h5>
<div class="outline-text-5" id="text-2-26-2-1">
<p>
A Trie is based on a tree structure.
<code>insert(word)</code> inserts a <code>word</code> into the trie.
<code>search(word)</code> tries to find a <code>word</code> in the trie, and returns <code>True</code> if it can find the <code>word</code>, else return <code>False</code>.
<code>startswith(prefix)</code> tries to find <code>prefix</code> in the trie, and returns <code>True</code> if it can find the <code>prefix</code>, else return <code>False</code>.
</p>

<p>
The difference between <code>search()</code> and <code>startswith()</code> is that the last character of the <code>word</code> for <code>search()</code> must be the last character in the trie as well, i.e. its <code>is_end</code> property must be <code>True</code>.
</p>
</div>
</div>

<div id="outline-container-org314a8c1" class="outline-5">
<h5 id="org314a8c1"><span class="section-number-5">2.26.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-26-2-2">
<p>
We use standard Trie structure with a <code>TrieNode</code> and a <code>Trie</code>.
</p>
</div>
</div>
<div id="outline-container-org5bf9184" class="outline-5">
<h5 id="org5bf9184"><span class="section-number-5">2.26.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-26-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 81: </span>208 Implementing Trie my solution</label><pre class="src src-python" id="orge609487">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;



<span class="org-keyword">class</span> <span class="org-type">Trie</span>:
    <span class="org-keyword">class</span> <span class="org-type">TrieNode</span>:

        <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, is_end=<span class="org-constant">False</span>, num_children=26):
            <span class="org-keyword">self</span>.is_end = is_end
            <span class="org-keyword">self</span>.num_children = num_children
            <span class="org-keyword">self</span>.links = [<span class="org-constant">None</span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-keyword">self</span>.num_children)]

        @<span class="org-builtin">property</span>
        <span class="org-keyword">def</span> <span class="org-function-name">is_end</span>(<span class="org-keyword">self</span>):
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>._is_end

        <span class="org-type">@is_end.setter</span>
        <span class="org-keyword">def</span> <span class="org-function-name">is_end</span>(<span class="org-keyword">self</span>, val):
            <span class="org-keyword">self</span>._is_end = val


        <span class="org-keyword">def</span> <span class="org-function-name">contains_key</span>(<span class="org-keyword">self</span>, ch: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>.links[<span class="org-builtin">ord</span>(ch)-<span class="org-builtin">ord</span>(<span class="org-string">'a'</span>)] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>

        <span class="org-keyword">def</span> <span class="org-function-name">get</span>(<span class="org-keyword">self</span>, ch: <span class="org-builtin">str</span>) -&gt; <span class="org-string">'TrieNode'</span>:
            <span class="org-keyword">return</span> <span class="org-keyword">self</span>.links[<span class="org-builtin">ord</span>(ch) - <span class="org-builtin">ord</span>(<span class="org-string">'a'</span>)]

        <span class="org-keyword">def</span> <span class="org-function-name">put</span>(<span class="org-keyword">self</span>, ch: <span class="org-builtin">str</span>, node: <span class="org-string">'TrieNode'</span>) -&gt; <span class="org-constant">None</span>:
            <span class="org-keyword">self</span>.links[<span class="org-builtin">ord</span>(ch) - <span class="org-builtin">ord</span>(<span class="org-string">'a'</span>)] = node

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">"""</span>
<span class="org-doc">        Initialize your data structure here.</span>
<span class="org-doc">        """</span>
        <span class="org-keyword">self</span>.root = <span class="org-keyword">self</span>.TrieNode()

    <span class="org-keyword">def</span> <span class="org-function-name">insert</span>(<span class="org-keyword">self</span>, word: <span class="org-builtin">str</span>) -&gt; <span class="org-constant">None</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Inserts a word into the trie.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">node</span> = <span class="org-keyword">self</span>.root
        <span class="org-keyword">for</span> ch <span class="org-keyword">in</span> word:
            <span class="org-keyword">if</span> <span class="org-keyword">not</span> node.contains_key(ch):
                node.put(ch, <span class="org-keyword">self</span>.TrieNode())
                
            <span class="org-variable-name">node</span> = node.get(ch)
            
        <span class="org-comment-delimiter"># </span><span class="org-comment">set the last node.is_end to True</span>
        <span class="org-variable-name">node.is_end</span> = <span class="org-constant">True</span>

    <span class="org-keyword">def</span> <span class="org-function-name">search</span>(<span class="org-keyword">self</span>, word: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Returns if the word is in the trie.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">node</span> = <span class="org-keyword">self</span>.search_prefix(word)
        <span class="org-keyword">return</span> (node <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>) <span class="org-keyword">and</span> node.is_end
    

    <span class="org-keyword">def</span> <span class="org-function-name">startsWith</span>(<span class="org-keyword">self</span>, prefix: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">bool</span>:
        <span class="org-doc">"""</span>
<span class="org-doc">        Returns if there is any word in the trie that starts with the given prefix.</span>
<span class="org-doc">        """</span>
        <span class="org-variable-name">node</span> = <span class="org-keyword">self</span>.search_prefix(prefix)
        <span class="org-keyword">return</span> node <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>


    <span class="org-keyword">def</span> <span class="org-function-name">search_prefix</span>(<span class="org-keyword">self</span>, prefix: <span class="org-builtin">str</span>) -&gt; TrieNode:
        <span class="org-variable-name">node</span> = <span class="org-keyword">self</span>.root
        <span class="org-keyword">for</span> ch <span class="org-keyword">in</span> prefix:
            <span class="org-keyword">if</span> node.contains_key(ch):
                <span class="org-variable-name">node</span> = node.get(ch)
            <span class="org-keyword">else</span>:
                <span class="org-keyword">return</span> <span class="org-constant">None</span>

        <span class="org-keyword">return</span> node
    

<span class="org-comment-delimiter"># </span><span class="org-comment">Your Trie object will be instantiated and called as such:</span>
<span class="org-variable-name">obj</span> = Trie()
<span class="org-variable-name">word</span>=<span class="org-string">"apple"</span>
obj.insert(word)
<span class="org-variable-name">param_2</span> = obj.search(word)
<span class="org-keyword">print</span>(param_2)
<span class="org-variable-name">word</span>=<span class="org-string">"app"</span>
obj.insert(word)
<span class="org-variable-name">param_2</span> = obj.search(word)
<span class="org-keyword">print</span>(param_2)
<span class="org-variable-name">prefix</span>=<span class="org-string">"apt"</span>
<span class="org-variable-name">param_3</span> = obj.startsWith(prefix)
<span class="org-keyword">print</span>(param_3)
<span class="org-variable-name">param_2</span> = obj.search(<span class="org-string">"aa"</span>)
<span class="org-keyword">print</span>(param_2)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 82: </span>208 Implementing Trie my solution-results</label><pre class="src src-python" id="org3d32912"><span class="org-constant">True</span>
<span class="org-constant">True</span>
<span class="org-constant">False</span>
<span class="org-constant">False</span>
</pre>
</div>
</div>
<div id="outline-container-org9436881" class="outline-6">
<h6 id="org9436881"><span class="section-number-6">2.26.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-26-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org575265e"></a>Time complexity:<br></li>

<li><a id="orgf962322"></a>Space complexity:<br></li>
</ol>
</div>
</div>

<div id="outline-container-orga369ec0" class="outline-5">
<h5 id="orga369ec0"><span class="section-number-5">2.26.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-26-2-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 83: </span>208 Implementing Trie leetcode solution</label><pre class="src src-python" id="org793ea7e">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 84: </span>208 Implementing Trie leetcode solution-results</label><pre class="src src-none" id="orgaafbeba">
</pre>
</div>
</div>
<div id="outline-container-org5d4a507" class="outline-6">
<h6 id="org5d4a507"><span class="section-number-6">2.26.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-orge05f673" class="outline-6">
<h6 id="orge05f673"><span class="section-number-6">2.26.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgc57c114" class="outline-4">
<h4 id="orgc57c114"><span class="section-number-4">2.26.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-26-3">
</div>
<div id="outline-container-org0f477d2" class="outline-5">
<h5 id="org0f477d2"><span class="section-number-5">2.26.3.1.</span> General thoughts</h5>
<div class="outline-text-5" id="text-2-26-3-1">
<p>
A Trie is built with two parts: a <code>TrieNode</code> and a <code>Trie</code>.
</p>

<p>
The most important thing to check for when building a <code>TrieNode</code> is the number of children it should have when <code>children</code> is an array of fixed length. In cases when we are not certain of the length, we can use HashMap.
</p>

<p>
The <code>TrieNode</code> should have at least three methods and one property to be functional: <code>put</code>, <code>get</code>, <code>contains_key</code>, and <code>is_end</code> as a property.
</p>

<p>
The three methods are meant to operate on <code>TrieNode.children</code>, which are basically modifications of array's <code>get</code>, <code>append</code>, <code>in</code> methods. They also have the same time complexity of \(O(1)\).
</p>

<p>
The <code>is_end</code> property marks whether the current node is the end of a word.
</p>

<p>
When we have a <code>TrieNode</code>, we then build a <code>Trie</code> upon it.
The most important thing with <code>Trie</code> is the subtle difference between a <code>prefix</code> and a <code>word</code>.
A <code>word</code> is also a prefix, but a <code>prefix</code> does not necessarily equal to a <code>word</code>.
A <code>prefix</code> is also a <code>word</code> iff <code>prefix.last_node.is_end==True</code>.
This tells us that, we can use the method <code>search_prefix(prefix)</code> to find the <code>prefix</code>, and also use it to find if a <code>word</code> is in the Trie, since we only need to check if the last node is also an end.
</p>

<p>
The <code>Trie</code> also have at least three methods to be functional: <code>insert</code>, <code>search_prefix</code> and <code>search_word</code>. Typically a <code>startswith</code> method will be added, and this is as trivial as <code>search_word</code>.
</p>
</div>
</div>
<div id="outline-container-orgccd14d2" class="outline-5">
<h5 id="orgccd14d2"><span class="section-number-5">2.26.3.2.</span> Related problems</h5>
</div>
</div>
</div>

<div id="outline-container-org29d379e" class="outline-3">
<h3 id="org29d379e"><span class="section-number-3">2.27.</span> <span class="todo TODO">TODO</span> 1038 Binary Search Tree to Greater Sum Tree</h3>
<div class="outline-text-3" id="text-2-27">
</div>
<div id="outline-container-org661f28c" class="outline-4">
<h4 id="org661f28c"><span class="section-number-4">2.27.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-27-1">
<p>
Given the root of a binary search tree with distinct values,
modify it so that every <code>node</code> has a new value equal to the sum of the values of
the original tree that are greater or equal to <code>node.val</code>.
</p>

<p>
As a reminder, a binary search tree is a tree that satisfies these constraints:
</p>

<ol class="org-ol">
<li>The left subtree of a node contains only nodes with keys less than the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ol>

<p>
Constraints:
</p>

<ol class="org-ol">
<li>The number of nodes in the tree is between 1 and 100.</li>
<li>Each node will have value between 0 and 100.</li>
<li>The given tree is a binary search tree.</li>
</ol>
</div>
<div id="outline-container-org6c02993" class="outline-5">
<h5 id="org6c02993"><span class="section-number-5">2.27.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-27-1-1">
<pre class="example" id="orgc44e939">

</pre>
</div>
</div>
</div>

<div id="outline-container-org4238393" class="outline-4">
<h4 id="org4238393"><span class="section-number-4">2.27.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-27-2">
</div>
<div id="outline-container-org79cff2c" class="outline-5">
<h5 id="org79cff2c"><span class="section-number-5">2.27.2.1.</span> Understanding the problem</h5>
<div class="outline-text-5" id="text-2-27-2-1">
<p>
The question is bit hard to understand at first but it is asking us to do the following.
</p>
<ol class="org-ol">
<li>We have a BST.</li>
<li>Start from the right-most leaf, we replace every node with,</li>
</ol>
<p>
<i>the sum of</i>, all values that are greater than the node, i.e, all values that are to the right of the node.
</p>
</div>
</div>
<div id="outline-container-org4687c1a" class="outline-5">
<h5 id="org4687c1a"><span class="section-number-5">2.27.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-27-2-2">
<p>
Like what is said in Understanding the problem, we start from the right-most leaf.
In this case, we use DFS and In-order traversal.
Every node's value is made of its original value plus the value of the node processed before it. 
</p>
</div>
</div>
<div id="outline-container-orgebf464a" class="outline-5">
<h5 id="orgebf464a"><span class="section-number-5">2.27.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-27-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 85: </span>1038 Binary Search Tree to Greater Sum Tree my solution</label><pre class="src src-python" id="orgb695135">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">Definition for a binary tree node.</span>
<span class="org-keyword">class</span> <span class="org-type">TreeNode</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, val=0, left=<span class="org-constant">None</span>, right=<span class="org-constant">None</span>):
        <span class="org-keyword">self</span>.val = val
        <span class="org-keyword">self</span>.left = left
        <span class="org-keyword">self</span>.right = right


<span class="org-keyword">class</span> <span class="org-type">Solution</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">bstToGst</span>(<span class="org-keyword">self</span>, root: TreeNode) -&gt; TreeNode:
        <span class="org-keyword">def</span> <span class="org-function-name">helper</span>(node) -&gt; <span class="org-constant">None</span>:
            <span class="org-keyword">nonlocal</span> running_sum
            <span class="org-keyword">if</span> node.right:
                helper(node.right)

            <span class="org-variable-name">node.val</span> += running_sum
            <span class="org-variable-name">running_sum</span> = node.val

            <span class="org-keyword">if</span> node.left:
                helper(node.left)

        <span class="org-variable-name">running_sum</span> = 0
        helper(root)
        <span class="org-keyword">return</span> root
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 86: </span>1038 Binary Search Tree to Greater Sum Tree my solution-results</label><pre class="src src-none" id="orgc890f67">
</pre>
</div>
</div>
<div id="outline-container-org2f3ec5a" class="outline-6">
<h6 id="org2f3ec5a"><span class="section-number-6">2.27.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-27-2-3-1">
</div>
<ol class="org-ol">
<li><a id="orgcfda1a7"></a>Time complexity:<br>
<div class="outline-text-7" id="text-2-27-2-3-1-1">
<p>
\(O(n)\), where \(n\) is the number of nodes in the BST.
</p>
</div>
</li>
<li><a id="org9400d20"></a>Space complexity:<br>
<div class="outline-text-7" id="text-2-27-2-3-1-2">
<p>
\(O(n)\), the space needed for the recursive stack.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgbfba6ce" class="outline-5">
<h5 id="orgbfba6ce"><span class="section-number-5">2.27.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-27-2-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 87: </span>1038 Binary Search Tree to Greater Sum Tree leetcode solution</label><pre class="src src-python" id="org58de6fe">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 88: </span>1038 Binary Search Tree to Greater Sum Tree leetcode solution-results</label><pre class="src src-none" id="org1718cf4">
</pre>
</div>
</div>
<div id="outline-container-org6bda938" class="outline-6">
<h6 id="org6bda938"><span class="section-number-6">2.27.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org16ff500" class="outline-6">
<h6 id="org16ff500"><span class="section-number-6">2.27.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgb8fb42d" class="outline-4">
<h4 id="orgb8fb42d"><span class="section-number-4">2.27.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-27-3">
</div>
<div id="outline-container-orgf847733" class="outline-5">
<h5 id="orgf847733"><span class="section-number-5">2.27.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-org1559c3b" class="outline-5">
<h5 id="org1559c3b"><span class="section-number-5">2.27.3.2.</span> Related problems</h5>
</div>
</div>
</div>


<div id="outline-container-org4288c1f" class="outline-3">
<h3 id="org4288c1f"><span class="section-number-3">2.28.</span> <span class="todo TODO">TODO</span> 21 Merge Two Sorted Lists</h3>
<div class="outline-text-3" id="text-2-28">
</div>
<div id="outline-container-org3112823" class="outline-4">
<h4 id="org3112823"><span class="section-number-4">2.28.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-28-1">
<p>
Merge two sorted linked lists and return it as a new <b>sorted</b> list.
The new list should be made by splicing together the nodes of the first two lists.
</p>

<p>
Constraints:
</p>
</div>

<div id="outline-container-org80cfd60" class="outline-5">
<h5 id="org80cfd60"><span class="section-number-5">2.28.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-28-1-1">
<pre class="example" id="orgccbcb3d">
Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</pre>
</div>
</div>
</div>

<div id="outline-container-org4595ff1" class="outline-4">
<h4 id="org4595ff1"><span class="section-number-4">2.28.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-28-2">
</div>
<div id="outline-container-org2a660f5" class="outline-5">
<h5 id="org2a660f5"><span class="section-number-5">2.28.2.1.</span> Understanding the problem</h5>
<div class="outline-text-5" id="text-2-28-2-1">
<p>
The problem gives two <i>sorted</i> linked lists <code>a</code> and <code>b</code>, and asks us to merge these two
together to form a new <i>sorted</i> linked list <code>c</code> that is:
</p>
<ol class="org-ol">
<li><del>in the same order as <code>a</code> and <code>b</code>, though this is not mentioned.</del></li>
<li>either descending or ascending.</li>
<li>ignorant of the order of elements from <code>a</code> and <code>b</code> when they are equal.</li>
</ol>

<p>
The lists could be empty or only have one node.
The lists could have different order.
</p>
</div>
</div>
<div id="outline-container-orgfea81fa" class="outline-5">
<h5 id="orgfea81fa"><span class="section-number-5">2.28.2.2.</span> Algorithm</h5>
<div class="outline-text-5" id="text-2-28-2-2">
<p>
We assume that <code>a</code> and <code>b</code> are both descending or ascending.
<del>We need to know whether <code>a</code> and <code>b</code> are descending or ascending.</del>
Actually, we can't know that ahead of time as the whole list could have a list of equal values.
</p>

<p>
<del>Once we know that, we pop each of the node of the lists and always use the smallest/largest node.</del>
We simply pop nodes from each list and compare the new nodes with the one we have to form the next node of the new list.
</p>

<p>
Or maybe we just quick sort them, considering <code>a</code> and <code>b</code> can have different orders???
</p>
</div>
</div>
<div id="outline-container-org919eb7c" class="outline-5">
<h5 id="org919eb7c"><span class="section-number-5">2.28.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-28-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 89: </span>21 Merge Two Sorted Lists my solution</label><pre class="src src-python" id="orgfeea9de">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">Definition for singly-linked list.</span>
<span class="org-keyword">class</span> <span class="org-type">ListNode</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, val=0, <span class="org-builtin">next</span>=<span class="org-constant">None</span>):
        <span class="org-keyword">self</span>.val = val
        <span class="org-keyword">self</span>.<span class="org-builtin">next</span> = <span class="org-builtin">next</span>

<span class="org-keyword">def</span> <span class="org-function-name">mergeTwoLists</span>(l1: ListNode, l2: ListNode) -&gt; ListNode:
    <span class="org-keyword">def</span> <span class="org-function-name">gen_node</span>(lst: ListNode):
        <span class="org-keyword">yield</span> lst
        <span class="org-variable-name">node</span> = lst
        <span class="org-keyword">while</span> node.<span class="org-builtin">next</span>:
            <span class="org-variable-name">node</span> = node.<span class="org-builtin">next</span>
            <span class="org-keyword">yield</span> node

    <span class="org-keyword">if</span> l1 == <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> l2

    <span class="org-keyword">if</span> l2 == <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> l1

    <span class="org-variable-name">gen_l1</span> = gen_node(l1)
    <span class="org-variable-name">gen_l2</span> = gen_node(l2)

    <span class="org-variable-name">res</span> = []

    <span class="org-keyword">for</span> node <span class="org-keyword">in</span> gen_l1:
        res.append(node)

    <span class="org-keyword">for</span> node <span class="org-keyword">in</span> gen_l2:
        res.append(node)

    <span class="org-variable-name">res</span> = <span class="org-builtin">sorted</span>(res, key=<span class="org-keyword">lambda</span> node: node.val)
    <span class="org-keyword">for</span> i, node <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(res):
        <span class="org-keyword">if</span> i == <span class="org-builtin">len</span>(res) - 1:
            <span class="org-keyword">break</span>
        node.<span class="org-builtin">next</span> = res[i+1]

    res[-1].<span class="org-builtin">next</span> = <span class="org-constant">None</span>

    <span class="org-keyword">return</span> res[0]
            
<span class="org-variable-name">l1_1</span> = ListNode(4)
<span class="org-variable-name">l1_2</span> = ListNode(2, l1_1)
<span class="org-variable-name">l1_3</span> = ListNode(1, l1_2)
<span class="org-variable-name">l2_1</span> = ListNode(4)
<span class="org-variable-name">l2_2</span> = ListNode(3, l2_1)
<span class="org-variable-name">l2_3</span> = ListNode(1, l2_2)

<span class="org-keyword">print</span>(mergeTwoLists(l1_3, l2_3).<span class="org-builtin">next</span>.<span class="org-builtin">next</span>.<span class="org-builtin">next</span>.val)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 90: </span>21 Merge Two Sorted Lists my solution-results</label><pre class="src src-python" id="orgf004ed4">3
</pre>
</div>
</div>
<div id="outline-container-orgef8b59c" class="outline-6">
<h6 id="orgef8b59c"><span class="section-number-6">2.28.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-28-2-3-1">
</div>
<ol class="org-ol">
<li><a id="orgd6f48a0"></a>Time complexity:<br></li>

<li><a id="org652c995"></a>Space complexity:<br></li>
</ol>
</div>
</div>

<div id="outline-container-org1d18df2" class="outline-5">
<h5 id="org1d18df2"><span class="section-number-5">2.28.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-28-2-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 91: </span>21 Merge Two Sorted Lists leetcode solution</label><pre class="src src-python" id="orgbd26a14">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 92: </span>21 Merge Two Sorted Lists leetcode solution-results</label><pre class="src src-none" id="org9b51d63">
</pre>
</div>
</div>
<div id="outline-container-orgc21a42c" class="outline-6">
<h6 id="orgc21a42c"><span class="section-number-6">2.28.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org783a77e" class="outline-6">
<h6 id="org783a77e"><span class="section-number-6">2.28.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-org01bd62c" class="outline-4">
<h4 id="org01bd62c"><span class="section-number-4">2.28.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-28-3">
</div>
<div id="outline-container-orgeddfb87" class="outline-5">
<h5 id="orgeddfb87"><span class="section-number-5">2.28.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-orga1a217c" class="outline-5">
<h5 id="orga1a217c"><span class="section-number-5">2.28.3.2.</span> Related problems</h5>
</div>
</div>
</div>



<div id="outline-container-org1f4e418" class="outline-3">
<h3 id="org1f4e418"><span class="section-number-3">2.29.</span> <span class="todo TODO">TODO</span> 20 Valid Parentheses</h3>
<div class="outline-text-3" id="text-2-29">
</div>
<div id="outline-container-org3f66c36" class="outline-4">
<h4 id="org3f66c36"><span class="section-number-4">2.29.1.</span> Description</h4>
<div class="outline-text-4" id="text-2-29-1">
<p>
Constraints:
</p>
</div>

<div id="outline-container-orgf86ceb5" class="outline-5">
<h5 id="orgf86ceb5"><span class="section-number-5">2.29.1.1.</span> Examples:</h5>
<div class="outline-text-5" id="text-2-29-1-1">
<pre class="example" id="orgb86ad3d">

</pre>
</div>
</div>
</div>

<div id="outline-container-org79f0bde" class="outline-4">
<h4 id="org79f0bde"><span class="section-number-4">2.29.2.</span> Solution</h4>
<div class="outline-text-4" id="text-2-29-2">
</div>
<div id="outline-container-org7d748a8" class="outline-5">
<h5 id="org7d748a8"><span class="section-number-5">2.29.2.1.</span> Understanding the problem</h5>
</div>

<div id="outline-container-org193ad1c" class="outline-5">
<h5 id="org193ad1c"><span class="section-number-5">2.29.2.2.</span> Algorithm</h5>
</div>

<div id="outline-container-orgfa5b3a4" class="outline-5">
<h5 id="orgfa5b3a4"><span class="section-number-5">2.29.2.3.</span> Code</h5>
<div class="outline-text-5" id="text-2-29-2-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 93: </span>20 Valid Parentheses my solution</label><pre class="src src-python" id="org0af70dd">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 94: </span>20 Valid Parentheses my solution-results</label><pre class="src src-none" id="orgd6a255e">
</pre>
</div>
</div>
<div id="outline-container-orgfa1c46f" class="outline-6">
<h6 id="orgfa1c46f"><span class="section-number-6">2.29.2.3.1.</span> Complexity</h6>
<div class="outline-text-6" id="text-2-29-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org9573177"></a>Time complexity:<br></li>

<li><a id="org24ecea5"></a>Space complexity:<br></li>
</ol>
</div>
</div>

<div id="outline-container-org99fa616" class="outline-5">
<h5 id="org99fa616"><span class="section-number-5">2.29.2.4.</span> Leetcode solution</h5>
<div class="outline-text-5" id="text-2-29-2-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 95: </span>20 Valid Parentheses leetcode solution</label><pre class="src src-python" id="org5167bfd">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 96: </span>20 Valid Parentheses leetcode solution-results</label><pre class="src src-none" id="org10fcc8f">
</pre>
</div>
</div>
<div id="outline-container-org1cf0697" class="outline-6">
<h6 id="org1cf0697"><span class="section-number-6">2.29.2.4.1.</span> Time complexity:</h6>
</div>

<div id="outline-container-org033e254" class="outline-6">
<h6 id="org033e254"><span class="section-number-6">2.29.2.4.2.</span> Space complexity:</h6>
</div>
</div>
</div>

<div id="outline-container-orgb3fa1bb" class="outline-4">
<h4 id="orgb3fa1bb"><span class="section-number-4">2.29.3.</span> More analysis</h4>
<div class="outline-text-4" id="text-2-29-3">
</div>
<div id="outline-container-org00e437b" class="outline-5">
<h5 id="org00e437b"><span class="section-number-5">2.29.3.1.</span> General thoughts</h5>
</div>
<div id="outline-container-org60db571" class="outline-5">
<h5 id="org60db571"><span class="section-number-5">2.29.3.2.</span> Related problems</h5>
</div>
</div>
</div>
</div>


<div id="outline-container-org07fc910" class="outline-2">
<h2 id="org07fc910"><span class="section-number-2">3.</span> Data structures</h2>
<div class="outline-text-2" id="text-3">
<p>
This section contains widely used data structures and related problems.
</p>
</div>
</div>
<div id="outline-container-org4a4139c" class="outline-2">
<h2 id="org4a4139c"><span class="section-number-2">4.</span> Algorithms</h2>
<div class="outline-text-2" id="text-4">
<p>
This section contains widely used algorithms and related problems.
</p>
</div>
<div id="outline-container-org064d0f5" class="outline-3">
<h3 id="org064d0f5"><span class="section-number-3">4.1.</span> Sorting</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org04dccae" class="outline-4">
<h4 id="org04dccae"><span class="section-number-4">4.1.1.</span> Insertion sort</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
In-place sort.
Easy to implement.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 97: </span>Insertion sort</label><pre class="src src-python" id="orgb80f57c"><span class="org-keyword">def</span> <span class="org-function-name">insertion_sort</span>(arr):
    <span class="org-variable-name">i</span> = 0
    <span class="org-keyword">while</span> i &lt; <span class="org-builtin">len</span>(arr):
        <span class="org-variable-name">j</span> = i
        <span class="org-keyword">while</span> j &gt; 0 <span class="org-keyword">and</span> arr[j-1] &gt; arr[j]:
            <span class="org-variable-name">temp</span> = arr[j-1]
            <span class="org-variable-name">arr</span>[j-1] = arr[j]
            <span class="org-variable-name">arr</span>[j] = temp
            <span class="org-variable-name">j</span> -= 1

        <span class="org-variable-name">i</span>+=1

    <span class="org-keyword">return</span> arr
<span class="org-keyword">print</span>(insertion_sort([2,1,3,4,2,5]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[1, 2, 2, 3, 4, 5]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaab4c60" class="outline-3">
<h3 id="orgaab4c60"><span class="section-number-3">4.2.</span> Dynamic programming</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The prerequisites for using DP are:
</p>
<ol class="org-ol">
<li>optimal substructure</li>
<li>overlaping sub-problems</li>
</ol>
</div>
<div id="outline-container-orgc89f2c8" class="outline-4">
<h4 id="orgc89f2c8"><span class="section-number-4">4.2.1.</span> Edit distance</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 98: </span>dynamic programming - edit distance</label><pre class="src src-python" id="orgd961cae"><span class="org-keyword">def</span> <span class="org-function-name">edit</span>(s: <span class="org-builtin">str</span>, t: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-keyword">def</span> <span class="org-function-name">get_element</span>(tbl: List[List[<span class="org-builtin">int</span>]], i: <span class="org-builtin">int</span>, j: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:

        <span class="org-keyword">if</span> i&gt;=0 <span class="org-keyword">and</span> j&gt;=0:
            <span class="org-keyword">return</span> tbl[i][j]
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> inf
        
    <span class="org-variable-name">m</span> = <span class="org-builtin">len</span>(s)
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(t)

    <span class="org-variable-name">tbl</span> = [[0 <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m+1)]


    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, m+1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, n+1):
            <span class="org-keyword">if</span> i==0 <span class="org-keyword">and</span> j==0:
                <span class="org-keyword">continue</span>
            tbl[i][j] = <span class="org-builtin">min</span>(1+get_element(tbl,i, j-1), 1+get_element(tbl,i-1, j), get_element(tbl, i-1, j-1)+(0 <span class="org-keyword">if</span> s[i-1]==t[j-1] <span class="org-keyword">else</span> 1))
    <span class="org-keyword">return</span> tbl[m][n]
<span class="org-keyword">print</span>(edit(<span class="org-string">"cbc"</span>, <span class="org-string">"ac"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">2
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 99: </span>dynamic programming - edit distance improved</label><pre class="src src-python" id="orge4a9ed5"><span class="org-keyword">def</span> <span class="org-function-name">edit</span>(s: <span class="org-builtin">str</span>, t: <span class="org-builtin">str</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-variable-name">m</span> = <span class="org-builtin">len</span>(s)
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(t)

    <span class="org-comment-delimiter"># </span><span class="org-comment">+1 accounts for the empty string in the table</span>
    <span class="org-variable-name">tbl</span> = [[0 <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)] <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m+1)]

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(m+1):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1):
            <span class="org-keyword">if</span> i == 0:
                tbl[i][j] = j
            <span class="org-keyword">elif</span> j==0:
                tbl[i][j] = i

            <span class="org-comment-delimiter"># </span><span class="org-comment">we want to compare the chars s[i-1] and t[j-1]</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">not the chars s[i] and t[j]</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">because at this point, i is in [1..m], j is in [1..n]</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">we need to map them back to [0..m-1] and [0..n-1]</span>
            <span class="org-keyword">elif</span> s[i-1]==t[j-1]:
                tbl[i][j] = tbl[i-1][j-1]
            <span class="org-keyword">else</span>:
                tbl[i][j] = 1+<span class="org-builtin">min</span>(tbl[i][j-1], <span class="org-comment-delimiter"># </span><span class="org-comment">insert</span>
                                  tbl[i-1][j], <span class="org-comment-delimiter"># </span><span class="org-comment">remove</span>
                                  tbl[i-1][j-1] <span class="org-comment-delimiter"># </span><span class="org-comment">replace</span>
                )
    <span class="org-keyword">return</span> tbl[m][n]

<span class="org-keyword">print</span>(edit(<span class="org-string">"abc"</span>, <span class="org-string">"ac"</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">1
</pre>
</div>
</div>
</div>
<div id="outline-container-orge213c16" class="outline-4">
<h4 id="orge213c16"><span class="section-number-4">4.2.2.</span> Discussions from <i>Introduction to Algorithms</i></h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
See <a href="#CLRS Dynamic programming">6.5</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org57c5ed9" class="outline-3">
<h3 id="org57c5ed9"><span class="section-number-3">4.3.</span> Dijkstra's Algorithm</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<a href="https://www.youtube.com/watch?v=pVfj6mxhdMw">https://www.youtube.com/watch?v=pVfj6mxhdMw</a>
</p>
</div>
</div>
<div id="outline-container-orgfeea56e" class="outline-3">
<h3 id="orgfeea56e"><span class="section-number-3">4.4.</span> Binary search</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Simple recursive solution.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">binary_search</span>(arr, left, right, target):
    <span class="org-doc">"""Return position of the target, or -1 if not found."""</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">check base case</span>
    <span class="org-keyword">if</span> left &lt;= right:
        <span class="org-variable-name">mid</span> = left + (right - left) // 2

        <span class="org-keyword">if</span> arr[mid] == target:
            <span class="org-keyword">return</span> mid
        <span class="org-keyword">elif</span> arr[mid] &gt; target:
            <span class="org-keyword">return</span> binary_search(arr, left, mid - 1, target)
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> binary_search(arr, mid + 1, right, target)

    <span class="org-keyword">return</span> -1
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org31c4875" class="outline-2">
<h2 id="org31c4875"><span class="section-number-2">5.</span> Techniques</h2>
<div class="outline-text-2" id="text-5">
<p>
This section contains techniques that do not make a full algorithm and related problems.
</p>
</div>
<div id="outline-container-org34a31de" class="outline-3">
<h3 id="org34a31de"><span class="section-number-3">5.1.</span> General</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-org5f70f26" class="outline-4">
<h4 id="org5f70f26"><span class="section-number-4">5.1.1.</span> Bitmask</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
See <a href="#78 Subsets Leetcode Solution">2.10.2.5</a>.
</p>

<p>
We have set of objects that we want to draw from. How do we represent the set's subsets such that we get its power set?
</p>

<p>
We can easily think of a map to associate with each object a boolean value, indicating whether the object is picked. The problem with this is that it can take a lot of memory and can be slow due to the overhead of creating the map.
</p>

<p>
So we can use bitmask.
</p>

<table id="org5badd25">


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">arr</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left">mask</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 100: </span>bitmask</label><pre class="src src-python" id="orga97c8b3"><span class="org-keyword">def</span> <span class="org-function-name">get_power_set</span>(arr: List[<span class="org-builtin">int</span>]) -&gt; List[List[<span class="org-builtin">int</span>]]:
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span>(arr)

    <span class="org-comment-delimiter"># </span><span class="org-comment">helps create left padding zeros</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">if n == 4, we have 1000</span>
    <span class="org-variable-name">nth_bit</span> = 1&lt;&lt;n

    <span class="org-variable-name">res</span> = [[]]
    <span class="org-comment-delimiter"># </span><span class="org-comment">time complexity: 2**n</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(2**n):
        <span class="org-comment-delimiter"># </span><span class="org-comment">if n==4, we might have 1000 | 010</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">1000 | 110, etc</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">[3:] takes out the leading "0b1" in "0b1010"</span>
        <span class="org-variable-name">mask</span> = <span class="org-builtin">bin</span>(nth_bit | i)[3:]
        <span class="org-variable-name">sub</span> = []
        <span class="org-comment-delimiter"># </span><span class="org-comment">time complexity: n</span>
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):
            <span class="org-keyword">if</span> mask[j] == <span class="org-string">"1"</span>:
                sub.append(arr[j])

        res.append(sub)
    <span class="org-keyword">return</span> res
<span class="org-keyword">print</span>(get_power_set([1,2,3]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[[], [], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org80a71b3" class="outline-3">
<h3 id="org80a71b3"><span class="section-number-3">5.2.</span> Python</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<code>k in dict.keys()</code> is \(O(1)\) because <a href="https://docs.python.org/3.5/library/stdtypes.html#dict-views">keys views are set-like since their are unique and hashable</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org16aefec" class="outline-2">
<h2 id="org16aefec"><span class="section-number-2">6.</span> CLRS Notes &amp; Yufei Tao lecture notes</h2>
<div class="outline-text-2" id="text-6">
<p>
Read chapters 3-4, 6-7, 10-17 and 22 of CLRS, and practice on LeetCode.
Also check Yufei Tao's lecture notes for concise introductions.
</p>
</div>

<div id="outline-container-orgf5de86d" class="outline-3">
<h3 id="orgf5de86d"><span class="section-number-3">6.1.</span> Growth of functions</h3>
<div class="outline-text-3" id="text-6-1">
<p>
We want to compare which algorithm performs better with respect to input size.
We study the <a href="#org562d77a">asymptotic</a> efficiency of algorithms when we make the input size large enough that only the order of growth of the running time is relevant.
</p>
</div>
<div id="outline-container-org562d77a" class="outline-4">
<h4 id="org562d77a"><span class="section-number-4">6.1.1.</span> Asymptotic notation</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Notations:
</p>
<ol class="org-ol">
<li>Domain for all functions of interest: \(\mathbb{N}\).</li>
<li>Worst-case running-time function \(T(n)\).</li>
</ol>
</div>

<div id="outline-container-org3b8f185" class="outline-5">
<h5 id="org3b8f185"><span class="section-number-5">6.1.1.1.</span> List of notations from YFT lecture notes:</h5>
<div class="outline-text-5" id="text-6-1-1-1">
</div>
<div id="outline-container-org3a2f937" class="outline-6">
<h6 id="org3a2f937"><span class="section-number-6">6.1.1.1.1.</span> Big-\(O\) (upper bound)</h6>
<div class="outline-text-6" id="text-6-1-1-1-1">
<p>
Let \(f(n)\) and \(g(n)\) be two functions of \(n\).
</p>

<p>
We say that \(f(n)\) grows asymptotically no faster than \(g(n)\) if there is a constant \(c_1>0\) and a constant \(c_2\) such that \(f(n)\le c_1 g(n)\) holds for all \(n \ge c_2\).
We denote this by \(f(n)=O(g(n))\).
</p>

<p>
The <b>time complexity</b> of an algorithm is described in the asymptotical form (big-O). 
</p>
</div>
</div>
<div id="outline-container-org4779061" class="outline-6">
<h6 id="org4779061"><span class="section-number-6">6.1.1.1.2.</span> Big-\(\Omega\) (lower bound)</h6>
<div class="outline-text-6" id="text-6-1-1-1-2">
<p>
Let \(f(n)\) and \(g(n)\) be two functions of \(n\).
If \(g(n)=O(f(n))\), then we define: \(f(n)=\Omega(g(n))\), to indicate that \(f(n)\) grows asymptotically no slower than \(g(n)\).
</p>
</div>
</div>
<div id="outline-container-org9dc1444" class="outline-6">
<h6 id="org9dc1444"><span class="section-number-6">6.1.1.1.3.</span> Big-\(\Theta\)</h6>
<div class="outline-text-6" id="text-6-1-1-1-3">
<p>
Let \(f(n)\) and \(g(n)\) be two functions of \(n\).
If \(f(n)=O(g(n)) \text{ and } f(n)=\Omega(g(n))\), in other words, \(f(n)=O(g(n)) \text{ and } g(n)=O(f(n))\), then we define: \(f(n)=\Theta(g(n))\).
This indicates that \(f(n)\) grows asymptotically as fast as \(g(n)\), no faster (big-\(O\)), no faster (big-\(\Omega\)).
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org1bb48b4" class="outline-4">
<h4 id="org1bb48b4"><span class="section-number-4">6.1.2.</span> Standard notations and common functions</h4>
<div class="outline-text-4" id="text-6-1-2">
</div>
</div>
</div>
<div id="outline-container-org21195e9" class="outline-3">
<h3 id="org21195e9"><span class="section-number-3">6.2.</span> Divide and conquer</h3>
<div class="outline-text-3" id="text-6-2">
<p>
We solve the problem recursively, applying the following 3 steps at each level of the recursion:
</p>
<ol class="org-ol">
<li><b>Divide</b> the problem into a number of subproblems that are smaller instances of the same problem (recursive case).</li>
<li><b>Conquer</b> the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner (base case).</li>
<li><b>Combine</b> the solutions to the subproblems into the solution for the original problem.</li>
</ol>
</div>
<div id="outline-container-orgfca76dd" class="outline-4">
<h4 id="orgfca76dd"><span class="section-number-4">6.2.1.</span> Recurrences</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
A <b>recurrence</b> is an equation of inequality that describes a function in terms of its value on smaller inputs.
</p>

<p>
The books provides 3 methods for obtaining the asymptotic \(\Theta\) or \(O\) bounds on the recurrence solution:
</p>
<ol class="org-ol">
<li><b>Substitution method</b> - we guess a bound and then use mathematical induction to prove our guess correct.</li>
<li><b>Recursion-tree method</b> - convert the recurrence into a tree whose nodes represent the costs incurred at various levels of the recursion. We use techniques for bounding summations to solve the recurrence.</li>
<li><a id="org0c4a836"></a> <b>Master method</b> - provides bounds for recurrences of the form \(T(n)=\underbrace{aT(n/b)}_{a \text{ subproblems}}+f(n),a\ge 1, b>1\) and \(f(n)\) is a given function.</li>
</ol>

<p>
To use the <a href="#org0c4a836">3</a>, 3 cases need to be memorized.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf7001e4" class="outline-3">
<h3 id="orgf7001e4"><span class="section-number-3">6.3.</span> Sorting</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The <b>sorting problem</b>:
</p>
<ul class="org-ul">
<li>Input: A sequence of \(n\) numbers \(\langle a_1, a_2,\ldots,a_n\rangle\).</li>
<li>Output: A permutation \(\langle a_1',a_2',\ldots,a_n'\rangle\) of the input sequence such that \(a_1'\le a_2'\le \ldots \le a_n'\).</li>
</ul>

<p>
Two kinds of sorting based on time complexity:
</p>
<ul class="org-ul">
<li>Comparison sort: sorted order is based only on comparison between the input elements</li>
<li>Non-comparison sort: use operations other than comparisons to determine the sorted order</li>
</ul>
<table id="org69d87ee">
<caption class="t-above"><span class="table-number">Table 1:</span> Sorting time complexity</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Algorithm</th>
<th scope="col" class="org-left">Worst-case runing time</th>
<th scope="col" class="org-left">Average-case/expected running time</th>
<th scope="col" class="org-left">Comparison?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Insertion sort</td>
<td class="org-left">\(\Theta(n^2)\)</td>
<td class="org-left">\(\Theta(n^2)\)</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">Merge</td>
<td class="org-left">\(\Theta(n\lg n)\)</td>
<td class="org-left">\(\Theta(n\lg n)\)</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">Heap</td>
<td class="org-left">\(O(n\lg n)\)</td>
<td class="org-left">-</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">Quick</td>
<td class="org-left">\(\Theta(n^2)\)</td>
<td class="org-left">\(\Theta(n\lg n)\) (expected)</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">Counting</td>
<td class="org-left">\(\Theta(k+n)\)</td>
<td class="org-left">\(\Theta(k+n)\)</td>
<td class="org-left">no</td>
</tr>

<tr>
<td class="org-left">Radix</td>
<td class="org-left">\(\Theta(d(k+n))\)</td>
<td class="org-left">\(\Theta(d(k+n))\)</td>
<td class="org-left">no</td>
</tr>

<tr>
<td class="org-left">Bucket</td>
<td class="org-left">\(\Theta(n^2)\)</td>
<td class="org-left">\(\Theta(n)\) (average-case)</td>
<td class="org-left">no</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org4a73e2a" class="outline-4">
<h4 id="org4a73e2a"><span class="section-number-4">6.3.1.</span> Heapsort&#xa0;&#xa0;&#xa0;<span class="tag"><span class="comparison_sort">comparison_sort</span></span></h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>Running time: \(O(n\lg n)\)</li>
<li>In-place: yes</li>
</ul>

<p>
The <b>(binary) heap</b> data structure is an <i>array</i> object that can be viewed as a nearly complete binary tree (some leaves might be empty). Each node of the tree corresponds to an element of the array.
</p>

<p>
A heap \(A\) is an array that has two attributes:
</p>
<ol class="org-ol">
<li>\(A.length\)</li>
<li>\(A.heap-size\), only \(A[1..A.heap-size]\) are valid elements to the heap</li>
</ol>
<p>
\(A.heap-size\le A.length\).
</p>
</div>

<div id="outline-container-org1bf8164" class="outline-5">
<h5 id="org1bf8164"><span class="section-number-5">6.3.1.1.</span> Heap properties</h5>
<div class="outline-text-5" id="text-6-3-1-1">
<p>
For any node \(i\), we have:
</p>
<ul class="org-ul">
<li>parent: \(\lfloor i/2\rfloor\).</li>
<li>left child: \(2i\)</li>
<li>right child: \(2i+1\)</li>
</ul>

<p>
There are two kinds of binary heaps: <b>max-heaps</b> and <b>min-heaps</b>.
For every node \(i\), they satisfy a <b>heap property</b>, 
</p>
<ul class="org-ul">
<li>max-heap: \(A[parent(i)]\ge A[i]\).</li>
<li>min-heap: \(A[parent(i)]\le A[i]\).</li>
</ul>

<p>
Max-heaps are used in the heapsort lagorithm; Min-heaps implement <a href="#org127f7b6">6.7.4</a>.
</p>
</div>
</div>

<div id="outline-container-org12fe203" class="outline-5">
<h5 id="org12fe203"><span class="section-number-5">6.3.1.2.</span> Max-Heapify (maintaining \(A[parent(i)]\ge A[i]\))</h5>
<div class="outline-text-5" id="text-6-3-1-2">
<p>
Here is the Python code for the Max-Heapify pseudo-code.
Time complexity: \(O(\lg n), n=A.length\).
</p>

<p>
The <code>max_heapify</code> lets the value at <code>A[i]</code> "float down" in the max-heap
so that the subtree rooted at index <code>i</code> obeys the max-heap property.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 101: </span>A 3-node construct that <code>max-heapify</code> works on</label><pre class="src src-ditaa" id="orgee0b6a8">/-------\
| arr(i)|
|       |
\-------/
/         \
/           \
/             \
/-------\               /-------\
| max   |               | max   |
| heap  |               | heap  |
\-------/               \-------/
</pre>
</div>


<figure id="org9653d75">
<img src="/assets/max-heapify-demo.png" alt="nil"/>

</figure>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 102: </span>max-heapify</label><pre class="src src-python" id="orgd907f83"><span class="org-keyword">def</span> <span class="org-function-name">max_heapify</span>(A, i, heap_size) -&gt; <span class="org-constant">None</span>:

    <span class="org-comment-delimiter"># </span><span class="org-comment">A is 0-indexed</span>
    <span class="org-variable-name">l</span> = 2*i+1
    <span class="org-variable-name">r</span> = 2*i+2

    <span class="org-variable-name">largest</span> = i
    <span class="org-keyword">if</span> l &lt; heap_size <span class="org-keyword">and</span> A[l]&gt;A[i]:
        <span class="org-variable-name">largest</span> = l
    <span class="org-keyword">if</span> r &lt; heap_size <span class="org-keyword">and</span> A[r]&gt;A[largest]:
        <span class="org-variable-name">largest</span> = r

    <span class="org-keyword">if</span> largest != i:
        A[i], <span class="org-variable-name">A</span>[largest] = A[largest], A[i]
        <span class="org-comment-delimiter"># </span><span class="org-comment">after exchanging A[i] and A[largest]</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the subtree now rooted at A[largest] might violate the max-heap property</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">thus we need to heapify it</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">at the end, the value of the original A[i] will float down</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">as many heights as possible</span>
        max_heapify(A, largest, heap_size)

<span class="org-comment-delimiter"># </span><span class="org-comment">The children of the root node must be already max-heaps</span>
<span class="org-variable-name">A</span> = [4,14,13,10,1,12]
max_heapify(A, 0, <span class="org-builtin">len</span>(A))
<span class="org-keyword">print</span>(A)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 103: </span>max-heapify-results</label><pre class="src src-none">[14, 10, 13, 4, 1, 12]
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb951008" class="outline-5">
<h5 id="orgb951008"><span class="section-number-5">6.3.1.3.</span> Building a heap</h5>
<div class="outline-text-5" id="text-6-3-1-3">
<p>
Here is the Python code for building the Build-Max-Heap pseudo-code from bottom to top (this is faster than "top-bottom" but the details are not important here).
This also makes sense because we start from the direct parent of leave nodes, which matches
the prerequisite of <code>max-heapify()</code> of having the child nodes of a 3-node construct to be 
max-heaps. In this case, those child nodes of a 3-node construct are leaves of the binary tree,
which are max-heaps with only one element.
</p>

<p>
As we go up the tree, all nodes that we have passed by are now roots of max-heaps, 
which again satisfies the condition of <code>max-heapify()</code> when used as child nodes of an upper node.
</p>

<p>
This is \(O(n)\). Although the obvious time complexity is \(O(n\lg n)\), we can prove that 
a tighter bound exists and it is \(O(n)\).
</p>

<p>
This makes sure that <b>all</b> elements \(A[i]\) in the heap satisfies:
\(A[parent(i)]\ge A[i]\).
</p>

<p>
Once again, compared to <code>max-heapify()</code>, this algorithm does not need its argument array to have children of the root as max-heaps already,
since this algorithm is going to achieve exactly that.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 104: </span>build-max-heap</label><pre class="src src-python" id="orgb858248">&lt;&lt;<span class="org-builtin">max</span>-heapify&gt;&gt;
<span class="org-keyword">def</span> <span class="org-function-name">build_max_heap</span>(A, heap_size) -&gt; <span class="org-constant">None</span>:

    <span class="org-comment-delimiter"># </span><span class="org-comment">we simply skip all leaves</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">because they are max-heaps with one element</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>((<span class="org-builtin">len</span>(A)//2-1), -1, -1):
        max_heapify(A, i, heap_size)

<span class="org-comment-delimiter">#</span><span class="org-comment">A = [4,14,7]</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">build_max_heap(A, len(A))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">print(A)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[14, 4, 7]
</pre>
</div>
</div>
</div>

<div id="outline-container-org95f7076" class="outline-5">
<h5 id="org95f7076"><span class="section-number-5">6.3.1.4.</span> Heapsort algorithm</h5>
<div class="outline-text-5" id="text-6-3-1-4">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 105: </span>heapsort</label><pre class="src src-python" id="orgd98f975">&lt;&lt;build-<span class="org-builtin">max</span>-heap&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">heapsort</span>(A):

    <span class="org-comment-delimiter"># </span><span class="org-comment">As the name suggests,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">build a max-heap out of array A.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">We have the largest number at root</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">after this</span>
    build_max_heap(A, <span class="org-builtin">len</span>(A)-1)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Keep changing root and the last element</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">max_heapify() guarantees that</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">the largest element pops to the root</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(A)-1, 0, -1):
        <span class="org-comment-delimiter"># </span><span class="org-comment">heap_size is i</span>
        A[0], <span class="org-variable-name">A</span>[i] = A[i], A[0]
        max_heapify(A, 0, i)

<span class="org-variable-name">A</span>=[3,13,2,123,4,1]        
heapsort(A)
<span class="org-keyword">print</span>(A)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">[14, 10, 7, 4, 1, 12]
[1, 2, 3, 4, 13, 123]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf94efd9" class="outline-5">
<h5 id="orgf94efd9"><span class="section-number-5">6.3.1.5.</span> Issues with heapsort in real world applications</h5>
<div class="outline-text-5" id="text-6-3-1-5">
<p>
Notes from <a href="https://www.cs.princeton.edu/courses/archive/spring13/cos226/lectures/24PriorityQueues-JH-2x2.pdf">Princeton COS 226</a>.
</p>

<p>
Performance on real computers is heavily impacted by really messy factors like cache performance.
</p>

<p>
Cache works in a way that when we fetch one memory address, its nearby addresses are fetched as well, since memory access patterns of most programs/algorithms are highly localized.
Therefore, in a \(n\times n\) matrix, <code>[arr[i][j] for j in range(n) for i in range(n)]</code> is faster than <code>[arr[j][i] for j in range(n) for i in range(n)]</code>, because when we fetched <code>arr[i][0]</code>, the computer already cached <code>arr[i][1]</code>, etc, for us. 
</p>

<table id="org2eebde9">
<caption class="t-above"><span class="table-number">Table 2:</span> Sort algorithms and cache performance</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Sorting algo</th>
<th scope="col" class="org-left">characteristic</th>
<th scope="col" class="org-left">cache-friendlyâ˜º?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mergesort</td>
<td class="org-left">sort subarrays first</td>
<td class="org-left">cache-friendly â˜º</td>
</tr>

<tr>
<td class="org-left">quicksort</td>
<td class="org-left">partition into subarrays</td>
<td class="org-left">cache-friendly â˜º</td>
</tr>

<tr>
<td class="org-left">heapsort</td>
<td class="org-left">all over the place</td>
<td class="org-left">cache-unfriendly ðŸ¤•</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org258f3de" class="outline-4">
<h4 id="org258f3de"><span class="section-number-4">6.3.2.</span> Quicksort&#xa0;&#xa0;&#xa0;<span class="tag"><span class="comparison_sort">comparison_sort</span></span></h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
Worst-case: \(\Theta(n^2)\).
Expected-case: \(O(n\lg n)\).
In-place: true.
</p>

<p>
Three step divide-and-conquer process for a subarray \(A[p..r]\):
</p>
<ul class="org-ul">
<li><b>Divide</b>: Partition \(A[p..r]\) into two (possibly empty) subarrays \(A[p..q-1]\) and \(A[q+1..r]\) such that \(a\le A[q]\le b, a\in A[p..q-1], b\in A[q+1, r]\). Compute the index \(q\) as part of this partition prcedure.</li>
<li><b>Conquer</b>: Sort the two subarrays \(A[p..q-1]\) and \(A[q+1..r]\) by recursive calls to quicksort.</li>
<li><b>Combine</b>: Because the subarrays are already sorted, no work is needed to combine them.</li>
</ul>
</div>

<div id="outline-container-orga8af38d" class="outline-5">
<h5 id="orga8af38d"><span class="section-number-5">6.3.2.1.</span> Implementation</h5>
<div class="outline-text-5" id="text-6-3-2-1">
<p>
Implementation of the above steps:
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 106: </span>quicksort</label><pre class="src src-python" id="orgb4097f4">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;
&lt;&lt;partitioning the array&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">quicksort</span>(arr, low, high):
    <span class="org-keyword">if</span> low &lt; high:
        <span class="org-variable-name">par_idx</span> = partition(arr, low, high)
        quicksort(arr, low, par_idx-1)
        quicksort(arr, par_idx+1, high)

<span class="org-variable-name">A</span> = [2,1,4,5]
quicksort(A, 0, <span class="org-builtin">len</span>(A)-1)
<span class="org-keyword">print</span>(A)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 107: </span>quicksort-results</label><pre class="src src-none">[1, 2, 4, 5]
</pre>
</div>

<p>
Implementation of partitioning the array:
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 108: </span>partitioning the array</label><pre class="src src-python" id="orgc9187cd"><span class="org-keyword">def</span> <span class="org-function-name">partition</span>(arr, low, high):
    <span class="org-doc">"""</span>
<span class="org-doc">    This function takes last element as pivot, places the pivot element at its</span>
<span class="org-doc">    correct position in sorted array, and places all smaller elements to the left of</span>
<span class="org-doc">    the pivot, and all greater elements to the right of the pivot.</span>

<span class="org-doc">    This partitions the arr in-place. Thus the for loop seems hard to understand.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">pivot</span> = arr[high]
    <span class="org-comment-delimiter"># </span><span class="org-comment">arr[low:i+1] is the smaller elements segment </span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">that are &lt;= pivot</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">i is the idx of the last smaller element</span>
    <span class="org-variable-name">i</span> = low - 1 
    <span class="org-comment-delimiter"># </span><span class="org-comment">After each the iteration:</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">arr[low:i+1] are smaller elements.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">arr[i+1:j] are larger elements.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">arr[j:high] are unchecked elements.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">arr[high] is the pivot</span>
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(low, high):
        <span class="org-comment-delimiter"># </span><span class="org-comment">if current element is smaller than</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">or equal to pivot</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">This means we can add another element</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">to the smaller elements segment</span>
        <span class="org-keyword">if</span> arr[j] &lt;= pivot:
            <span class="org-comment-delimiter"># </span><span class="org-comment">increment index of smaller element</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">because we found one smaller element at arr[j]</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">and is going to exchange it with arr[i]</span>
            <span class="org-variable-name">i</span> += 1
            <span class="org-comment-delimiter"># </span><span class="org-comment">if j&gt;i, that means arr[i] &gt; pivot</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">we need to exchange that with arr[j].</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">otherwise, there is no need to exchange </span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">arr[j] and arr[i]</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">however, this condition can be ignored,</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">as it does not slow down the operation</span>
            <span class="org-keyword">if</span> j&gt;i:
                arr[i], <span class="org-variable-name">arr</span>[j] = arr[j], arr[i]

    <span class="org-comment-delimiter"># </span><span class="org-comment">exchange the smallest element in the larger segment</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">with the pivot</span>
    arr[i+1], <span class="org-variable-name">arr</span>[high] = arr[high], arr[i+1]
    <span class="org-keyword">return</span> i+1
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ad9a06" class="outline-5">
<h5 id="org3ad9a06"><span class="section-number-5">6.3.2.2.</span> Notes on choosing the <i>pivot</i> and running time</h5>
<div class="outline-text-5" id="text-6-3-2-2">
<p>
We can randomly pick any \(i\) in \(A\) to be our pivot. And this random picking process can be done in \(O(1)\) time.
</p>

<p>
Because this is a randomized algorithm, its running time is a <b>random variable</b> depending on the random choices made. Thus we can only get its running time as follows:
</p>
<table id="org9c4b648">
<caption class="t-above"><span class="table-number">Table 3:</span> Quicksort running time</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Case</th>
<th scope="col" class="org-left"># of elements in segments after each partitioning</th>
<th scope="col" class="org-left">Running time</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Worst</td>
<td class="org-left">n-1 elements and 0 elements</td>
<td class="org-left">\(O(n^2)\)</td>
</tr>

<tr>
<td class="org-left">Best</td>
<td class="org-left">\(\lfloor n/2 \rfloor\), \(\lceil n/2 \rceil -1\)</td>
<td class="org-left">\(O(n\lg n)\)</td>
</tr>

<tr>
<td class="org-left">Average</td>
<td class="org-left">as long as segment not empty (not the worst)</td>
<td class="org-left">\(O(n\lg n)\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org55f876a" class="outline-4">
<h4 id="org55f876a"><span class="section-number-4">6.3.3.</span> Sorting in linear time</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
We assume all input elements are distinct, without loss of generality.
</p>
</div>
<div id="outline-container-orgdcb4ae1" class="outline-5">
<h5 id="orgdcb4ae1"><span class="section-number-5">6.3.3.1.</span> <span class="todo TODO">TODO</span> Decision-tree</h5>
<div class="outline-text-5" id="text-6-3-3-1">
<p>
Comparison sorts can be viewed abstractly in terms of decision trees.
A decision tree is a full binary tree that represents the comparisons between elements 
that are performed by a particular sorting algorithm operating on an input of a given size.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org27f93ab" class="outline-3">
<h3 id="org27f93ab"><span class="section-number-3">6.4.</span> Medians and order statistics</h3>
<div class="outline-text-3" id="text-6-4">
</div>
<div id="outline-container-org64070cc" class="outline-4">
<h4 id="org64070cc"><span class="section-number-4">6.4.1.</span> Definition</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
The \(i\) th <b>order statistic</b> of a set of \(n\) elements is the \(i\) th smallest element.
For example, the <b>minimum</b> of a set of elements is the first order statistic (\(i=1\)),
and the <b>maximum</b> is the \(n\) th order statistic (\(i=n\)). A <b>median</b>, is the middle of the set.
</p>

<p>
The <b>selection problem</b>:
</p>
<ul class="org-ul">
<li>Input: A set \(A\) of \(n\) (distinct) numbers and an integer \(i\), with \(1\le i \le n\).</li>
<li>Output: The element \(x \in A,a_1< a_2 < \ldots < a_{i-1},x < a_{i+1}\ldots a_n\).</li>
</ul>
</div>
</div>
<div id="outline-container-orgedf6f64" class="outline-4">
<h4 id="orgedf6f64"><span class="section-number-4">6.4.2.</span> <span class="done DONE">DONE</span> Selection in expected linear time (Quickselect)</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
We use <code>randomized_select</code> modeled after the <a href="#org258f3de">6.3.2</a> algorithm but only works on one side of a partition.
</p>

<p>
Implementation of Quickselect from<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60547/Python-quick-select-(use-partition)-average-time-O(N)-and-worst-O(N2)">Leetcode</a>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 109: </span>Quickselect python implementation</label><pre class="src src-python" id="org130444a"><span class="org-keyword">import</span> random

<span class="org-keyword">def</span> <span class="org-function-name">partition</span>(arr, l, r):
    <span class="org-variable-name">x</span> = arr[r]
    <span class="org-variable-name">i</span> = l

    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(l, r):
        <span class="org-comment-delimiter"># </span><span class="org-comment">use &gt; to sort the elements in descending order</span>
        <span class="org-keyword">if</span> arr[j] &gt; x:
            arr[i], <span class="org-variable-name">arr</span>[j] = arr[j], arr[i]
            <span class="org-variable-name">i</span> += 1

    arr[i], <span class="org-variable-name">arr</span>[r] = arr[r], arr[i]
    <span class="org-keyword">return</span> i

<span class="org-keyword">def</span> <span class="org-function-name">quick_select</span>(nums, start, n, k):
    <span class="org-comment-delimiter"># </span><span class="org-comment">get random pivot index</span>
    <span class="org-variable-name">rand_pivot_idx</span> = random.randrange(start, n+1)
    nums[n], <span class="org-variable-name">nums</span>[rand_pivot_idx] = nums[rand_pivot_idx], nums[n]
    <span class="org-variable-name">pos</span> = partition(nums, start, n)
    <span class="org-keyword">if</span> pos == k-1:
        <span class="org-keyword">return</span> nums[pos]
    <span class="org-keyword">elif</span> pos &gt;= k:
        <span class="org-keyword">return</span> quick_select(nums, start, pos-1, k)
    <span class="org-keyword">return</span> quick_select(nums, pos+1, n, k)

<span class="org-keyword">def</span> <span class="org-function-name">find_kth_largest</span>(nums, k):
    <span class="org-keyword">return</span> quick_select(nums, 0, <span class="org-builtin">len</span>(nums)-1, k)

<span class="org-keyword">print</span>(find_kth_largest([3,2,1,5,6,4], 1))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">6
</pre>
</div>
</div>
</div>
<div id="outline-container-orgacaa445" class="outline-4">
<h4 id="orgacaa445"><span class="section-number-4">6.4.3.</span> <span class="todo TODO">TODO</span> Selection in worst-case linear time (median-of-medians)</h4>
<div class="outline-text-4" id="text-6-4-3">
<p>
Steps to select:
</p>
<ol class="org-ol">
<li>Divide the \(n\) elements of the input array into \(\lfloor n/5 \rfloor\) groups and at most one group made up of the remaining \(n \mod 5\) elements.</li>
<li>Find the median of each of the \(\lceil n/5 \rceil\) groups by first insertion-sorting the elements of each group.</li>
<li>Use <code>select()</code> recursively to find the median \(x\) of the \(\lceil n/5 \rceil\) medians found in step 2.</li>
<li>Partition the input array around the median-of-medians \(x\) using the modified version of <code>partition</code>. Let \(k\) be one more than the number of elements on the low side of the partition, so that \(x\) is the kth smallest element and there are \(n-k\) elements on the high side of the partition.</li>
<li>If \(i=k\), then return \(x\), otherwise, use <code>select</code> recursively to find the ith smallest element on the low side if \(i<k\), or the \((i-k)\) th smallest element on the high side if \(i>k\).</li>
</ol>

<p>
Python implementation of the algorithm.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 110: </span>selection worst case linear</label><pre class="src src-python" id="org8820dda"><span class="org-keyword">def</span> <span class="org-function-name">partition</span>(arr, lo, hi, pivot) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(lo, hi):
        <span class="org-keyword">if</span> arr[i] == pivot:
            arr[hi], <span class="org-variable-name">arr</span>[i] = arr[i], arr[hi]
            <span class="org-keyword">break</span>

        
    <span class="org-variable-name">i</span> = lo

    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(lo, hi):
        <span class="org-keyword">if</span> arr[j] &gt;= pivot:
            arr[j], <span class="org-variable-name">arr</span>[i] = arr[i], arr[j]
            <span class="org-variable-name">i</span> += 1

    arr[i], <span class="org-variable-name">arr</span>[hi] = arr[hi], arr[i]
    <span class="org-keyword">return</span> i

<span class="org-keyword">def</span> <span class="org-function-name">find_median</span>(arr, lo, n):
    <span class="org-variable-name">lst</span> = []
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(lo, lo+n):
        lst.append(arr[i])

    lst.sort()

    <span class="org-keyword">return</span> lst[n//2]


<span class="org-keyword">def</span> <span class="org-function-name">select</span>(arr, lo, hi, k) -&gt; <span class="org-builtin">int</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">number of elements in arr[lo, hi]</span>
    <span class="org-variable-name">n</span> = hi - lo + 1
    <span class="org-variable-name">medians</span> = []

    <span class="org-variable-name">i</span> = 0
    <span class="org-keyword">while</span> (i&lt;n//5):
        medians.append(find_median(arr, lo+i*5, 5))
        <span class="org-variable-name">i</span> += 1
        
    <span class="org-comment-delimiter"># </span><span class="org-comment">last group</span>
    <span class="org-keyword">if</span> i*5 &lt; n:
        medians.append(find_median(arr, lo+i*5, n%5))
        <span class="org-variable-name">i</span>+=1

    <span class="org-comment-delimiter"># </span><span class="org-comment">Find median of all medians using recursive call.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">If medians has only one element, then no need</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">of recursive call</span>
    <span class="org-keyword">if</span> i == 1:
        <span class="org-variable-name">med_of_meds</span> = medians[0]
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">med_of_meds</span> = select(medians, 0, i-1, i//2)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Partition the array around a med_of_meds</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">element and get position of pivot</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">element in sorted array</span>
    <span class="org-variable-name">pos</span> = partition(arr, lo, hi, med_of_meds)

    <span class="org-comment-delimiter"># </span><span class="org-comment">If position is the same as k</span>
    <span class="org-keyword">if</span> (pos - lo == k - 1):
        <span class="org-keyword">return</span> arr[pos]
    <span class="org-comment-delimiter"># </span><span class="org-comment">If position is more,</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">recur for left subarray</span>
    <span class="org-keyword">if</span> (pos - lo &gt; k-1):
        <span class="org-keyword">return</span> select(arr, lo, pos-1, k)
    

    <span class="org-comment-delimiter"># </span><span class="org-comment">Else recur for right subarray</span>
    <span class="org-keyword">return</span> select(arr, pos+1, hi, k-pos+lo-1)
<span class="org-keyword">print</span>(select([1,2,3,4,5],0, 4, 2))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">4
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-CLRS Dynamic programming" class="outline-3">
<h3 id="CLRS Dynamic programming"><span class="section-number-3">6.5.</span> Dynamic programming</h3>
<div class="outline-text-3" id="text-CLRS Dynamic programming">
<p>
Dynamic programming solves problems by combining the solutions to subproblems. "Programming" in this context refers to
a tabular mothod, not to writing computer code.
</p>

<p>
DP is usually applied to <b>optimization problems</b> that can be divided into subproblems,
and these subproblems have overlapping subsubprolems, i.e. they share some common subsubproblems.
</p>

<p>
Usually, there exist multiple solutions to a problem, and we want <i>a</i> solution that gives an optimal 
(minimum or maximum) value, since there might also exist multiple solutions that give us the same
optimal value.
</p>
</div>
<div id="outline-container-orgb4e83f0" class="outline-4">
<h4 id="orgb4e83f0"><span class="section-number-4">6.5.1.</span> Four steps to develop a dynamic programming algorithm</h4>
<div class="outline-text-4" id="text-6-5-1">
<ol class="org-ol">
<li><a id="org5ffcf39"></a>Characterize the structure of an optimal solution</li>
<li><a id="org0d78c2e"></a>Recursively define the value of an optimal solution</li>
<li>Compute the value of an optimal solution, typically in a bottom-up fashion</li>
<li>Construct an optimal solution from computed information
<ol class="org-ol">
<li>This step is only needed when we want <i>not only the value of the solution</i>, but also the <i>solution</i> itself.</li>
<li>This step is where DP needs \(O(N)\) space (if input is one dimentional array) as it needs to store the computed information.</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org26ff9ce" class="outline-4">
<h4 id="org26ff9ce"><span class="section-number-4">6.5.2.</span> Rod cutting example</h4>
<div class="outline-text-4" id="text-6-5-2">
</div>
<div id="outline-container-orgd707692" class="outline-5">
<h5 id="orgd707692"><span class="section-number-5">6.5.2.1.</span> The problem</h5>
<div class="outline-text-5" id="text-6-5-2-1">
<p>
Given a rod of length <code>n</code> inches and a table of <code>prices[i], i=1,2,...,n</code>, determine the maximum revenue <code>rn</code> obtainable
by cutting up the rod and selling the pieces. Note that if the price <code>prices[n]</code> for a rod of length
<code>n</code> is large enough, an optimal solution may require no cutting at all.
</p>
</div>
</div>
<div id="outline-container-org4417131" class="outline-5">
<h5 id="org4417131"><span class="section-number-5">6.5.2.2.</span> The solution</h5>
<div class="outline-text-5" id="text-6-5-2-2">
<p>
To cut a rod of length <code>n</code> into rods of 1 inch, we need to cut <code>n-1</code> times.
By thinking of this as a problem of bitmasking, where we have a binary number of <code>n-1</code> bits,
and 1 represents cut, 0 represents no cut, it is easy to deduce that the number of possible ways
to cut the rod is \(2^{n-1}\).
</p>

<p>
Given the <code>prices</code> table, any revenue \(r_n\) of a length <code>n</code> rod can be represented as follows:
\(r_n=\max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1)\). (<a href="#org0d78c2e">Recursively define the value of an optimal solution</a>)
\(p_n\) corresponds to making no cuts at all. The remaining <code>n-1</code> arguments correspond to the maximum
revenue obtained by making an initial cut of the rod into two pieces of size <code>i</code> and <code>n-i</code>, 
for each \(i=1,2,...,n-1\), and then optimally cutting up those pieces further, 
obtaining revenues \(r_i\) and and \(r_{n-i}\) from those two pieces.
</p>

<p>
We say the rod-cutting problem exihibits <b>optimal substructure</b>, i.e. optimal solutions to a problem
incorporate optimal solutions to related subproblems, which we may solve independently.
It also has overlapping subsubproblems. For example, one needs to \(r_1\) twice for \(r_i\) and \(r_{n-i}\).
</p>

<p>
The equation \(r_n=\max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1)\) has duplicate values
since when doing cutting (bitmasking), "100" is the same as "001".
Therefore, we can simplify this process of cutting by the following:
</p>
<ol class="org-ol">
<li>We cut a first piece of length <code>i</code> off the left-hand end</li>
<li>We only further divided the right-hand end remainder of length <code>n-i</code>.</li>
<li>The revenue is then \(r_n=\max_{1\le i\le n}(p_i+r_{n-i})\), which removes one recursion (\(r_i\)) for us.</li>
</ol>
</div>

<div id="outline-container-orge45f25e" class="outline-6">
<h6 id="orge45f25e"><span class="section-number-6">6.5.2.2.1.</span> Recursive top-down implementation</h6>
<div class="outline-text-6" id="text-6-5-2-2-1">
<p>
Here is an implementation of the above formula \(r_n=\max_{1\le i\le n}(p_i+r_{n-i})\).
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 111: </span>cutting rod recursive top-down implementation</label><pre class="src src-python" id="org7245a4f">&lt;&lt;imports <span class="org-keyword">for</span> typing&gt;&gt;
<span class="org-keyword">def</span> <span class="org-function-name">cut_rod</span>(p: List[<span class="org-builtin">int</span>], n: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">int</span>:
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-keyword">if</span> n == 0:
        <span class="org-keyword">return</span> 0
    <span class="org-variable-name">q</span> = -inf
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n+1):
        <span class="org-comment-delimiter"># </span><span class="org-comment">implementation detail</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the array in the book starts with 1</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">here the array starts with 0</span>
        <span class="org-variable-name">q</span> = <span class="org-builtin">max</span>(q, p[i-1]+cut_rod(p, n-i))
    <span class="org-keyword">return</span> q
<span class="org-keyword">print</span>(cut_rod([1,2,3,9], 3))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">3
</pre>
</div>

<p>
This implementation is slow because it's time complexity is \(O(n^2),\text{ where }n=\text{len}(p)\).
Many same operations were done multiple times. 
For example, when solving <code>cut_rod(p, n)</code> and <code>cut_rod(p, n-1)</code>, <code>cut_rod(p, n-2)</code> was calculated twice.
</p>
</div>
</div>

<div id="outline-container-org672ed32" class="outline-6">
<h6 id="org672ed32"><span class="section-number-6">6.5.2.2.2.</span> Dynamic programming solution</h6>
<div class="outline-text-6" id="text-6-5-2-2-2">
<p>
We only need to solve one problem in <a href="#orge45f25e">6.5.2.2.1</a> to make it significantly faster,
namely, we want to solve each subproblem exactly <b>once</b> and save it (extra memory) for future use.
</p>

<p>
Dynamic programming runs in polynomial time when the number of <i>distinct</i> subproblems involved
is polynomial in the input size and we can solve each sub subproblem in polynomial time.
There are usually two ways to implement a dynamic programming approach - top-down with memoization
and bottom-up.
</p>

<p>
Top-down with memoization:
</p>
<ol class="org-ol">
<li>Recursive</li>
<li>Save the result of each subproblem in an array or hash table</li>
<li>For every subproblem, first check if we have already solved it</li>
<li>If so, just return the value</li>
<li>If not, compute the value for the subproblem</li>
</ol>

<p>
Bottom-up:
</p>
<ol class="org-ol">
<li>Typically depends on some natural notion of the "size" of a subproblem, s.t. solving any particular subproblem depends only on solving "smaller" subproblems.</li>
<li>We sort the subproblems by size and solve them in size order, smallest first.</li>
<li>When solving a particular subproblem, we have already solved all of the smaller subproblems its solution depends upon beforehand, and we have saved their solutions.</li>
</ol>

<p>
These two methods are asymptotically the same.
</p>
</div>

<ol class="org-ol">
<li><a id="org164c13d"></a>top-bottom approach code<br>
<div class="outline-text-7" id="text-6-5-2-2-2-1">
<p>
Here is the Python code for dynamic programming using top-bottom memoization method.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 112: </span>top-bottom dynamic programming meoization</label><pre class="src src-python" id="orge2af453"><span class="org-keyword">def</span> <span class="org-function-name">memoized_cut_rod</span>(p, n):
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf
    <span class="org-keyword">def</span> <span class="org-function-name">memoized_cut_rod_aux</span>(p, n, r):
        <span class="org-keyword">if</span> r[n] &gt;= 0:
            <span class="org-keyword">return</span> r[n]
        <span class="org-keyword">if</span> n == 0:
            <span class="org-variable-name">q</span> = 0
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">q</span> = -inf
            <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n+1):
                <span class="org-variable-name">q</span> = <span class="org-builtin">max</span>(q, p[i-1]+memoized_cut_rod_aux(p, n-i, r))
                <span class="org-variable-name">r</span>[n] = q
        <span class="org-keyword">return</span> q

    <span class="org-variable-name">r</span> = [-inf <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)]

    <span class="org-keyword">return</span> memoized_cut_rod_aux(p, n, r)
<span class="org-keyword">print</span>(memoized_cut_rod([1,2,3,9], 3))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">3
</pre>
</div>
</div>
</li>

<li><a id="org9c96539"></a>bottom-up approach code<br>
<div class="outline-text-7" id="text-6-5-2-2-2-2">
<p>
Here is the bottom-up approach, which is simpler and easier to understand for me.
Recall the revenue is \(r_n=\max_{1\le i\le n}(p_i+r_{n-i})\).
We need to prove that \(r_n=\max(p_n, r_1+r_{n-1}, r_2+r_{n-2},...,r_{n-1}+r_1)\) is in effect
equivalent to \(r_n=\max_{1\le i\le n}(p_i+r_{n-i})\), so that we can justify the use of an inner loop in the code below.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 113: </span>bottom-up dynamic programming approach</label><pre class="src src-python" id="orgfb8e8d8"><span class="org-keyword">def</span> <span class="org-function-name">bottom_up_cut_rod</span>(p, n):
    <span class="org-keyword">from</span> math <span class="org-keyword">import</span> inf

    <span class="org-variable-name">r</span> = [0 <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n+1)]
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n+1):
        <span class="org-variable-name">q</span> = -inf
        <span class="org-comment-delimiter"># </span><span class="org-comment">This inner loop is introduced because</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">we cannot know, ahead of time, the best cutting strategy</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">that will give us the highest return.</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">Therefore we need to check all possible strategies,</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">which were already calculated.</span>
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, i+1):
            <span class="org-comment-delimiter"># </span><span class="org-comment">p[j-1] is the price of a length j rod</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">r[i-j] is the best return of length i-j rod, which should be already calculated</span>
            <span class="org-comment-delimiter">#</span><span class="org-comment">q = max(q, p[j-1] + r[i-j])</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">q is the possible return from previous operations in this inner loop</span>
            <span class="org-variable-name">q</span> = <span class="org-builtin">max</span>(q, r[j] + r[i-j], p[j-1]) <span class="org-comment-delimiter"># </span><span class="org-comment">this is easier to understand</span>
            <span class="org-variable-name">r</span>[i] = q
    <span class="org-keyword">return</span> r[n]
<span class="org-keyword">print</span>(bottom_up_cut_rod([1,4,4,4,9], 4))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-none">8
</pre>
</div>
</div>
</li>

<li><a id="org56a1170"></a>Reconstructing a solution<br>
<div class="outline-text-7" id="text-6-5-2-2-2-3">
</div>
</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-org96c4a23" class="outline-3">
<h3 id="org96c4a23"><span class="section-number-3">6.6.</span> Single-Source Shortest Paths</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Relaxation in Dijkstra's Algorithm: <a href="http://web.cs.unlv.edu/larmore/Courses/CSC269/pathing">http://web.cs.unlv.edu/larmore/Courses/CSC269/pathing</a>.
</p>
<blockquote>
<p>
The notion of "relaxation" comes from an analogy between the estimate of the
shortest path and the length of a helical tension spring, which is not
designed for compression. Initially, the cost of the shortest path is an
overestimate, likened to a stretched out spring. As shorter paths are found,
the estimated cost is lowered, and the spring is relaxed. Eventually, the
shortest path, if one exists, is found and the spring has been relaxed to its
resting length.
</p>
</blockquote>
</div>
<div id="outline-container-orga95de7e" class="outline-4">
<h4 id="orga95de7e"><span class="section-number-4">6.6.1.</span> Definition</h4>
<div class="outline-text-4" id="text-6-6-1">
<p>
In a <b>shortest-paths problem</b>, we are given a weighted, directed graph \(G=(V, E)\),
with weight function \(w: E \rightarrow \mathbb{R}\) mapping edges to real-valued weights.
The <b>weight</b> \(w(p)\) of a path \(p=\langle v_0, v_1,\ldots,v_k\rangle\) is the sum of the
weights of its constituent edges:
</p>
\begin{equation}
w(p) = \sum_{i=1}^k w(v_{i-1}, v_i)
\end{equation}

<p>
We define the <b>shortest-path weight</b> \(\delta(u,v)\) from \(u\) to \(v\) by
</p>
\begin{equation}
\delta(u,v)= \begin{cases}

\min{\{ w(p): u \overset{p}{\leadsto} v\}} &\text{if there is a path from \(u\) to \(v\)}\\
\infty &\text{else}

\end{cases}
\end{equation}
<p>
To put it simply, the <b>shortest-path weight</b> from \(u\) to \(v\) either
</p>
<ol class="org-ol">
<li>does not exist (\(\infty\)), or</li>
<li>is the minimum weight of all possible weights of different paths (or simply one path) from \(u\) to \(v\).</li>
</ol>

<p>
A <b>shortest path</b> from vertex \(u\) to vertex \(v\) is then defined as any path \(p\) with weight
\(w(p)=\delta (u,v)\).
</p>

<p>
Concepts:
</p>
<ol class="org-ol">
<li>Vertices, that are connected to create</li>
<li>directed Edges, that are given real-valued</li>
<li>Weights</li>
<li>Directed Edges with Weights, that form</li>
<li>Paths with Weights</li>
</ol>

<p>
<b>Single-source shortest-paths problem</b> (SSSP): Given a directed graph \(G=(V, E)\), we want to find a shortest path
from a <i>given</i> source vertex \(s\in V\) to each vertex \(v\in V\).
</p>

<p>
This seems also like a dynamic programming problem because:
</p>
<ol class="org-ol">
<li>We are looking fo a minimum value</li>
<li>This value can be obtained by obtaining the minimum value of subproblems of the same kind</li>
</ol>
</div>
<div id="outline-container-org63ded9a" class="outline-5">
<h5 id="org63ded9a"><span class="section-number-5">6.6.1.1.</span> Variants of the SSSP problem</h5>
<div class="outline-text-5" id="text-6-6-1-1">
<p>
<b>Single-destination shortest-paths problem</b>: Find a shortest path to a given <b>destination</b> vertex
\(t\) from each vertex \(v\). By reversing the direction of each edge in the graph, we can reduce this problem to SSSP.
</p>

<p>
<b>Single-pair shortest-path problem</b>: Find a shortest path from \(u\) to \(v\) fro given vertices \(u\) and \(v\). If we solve the SSSP problem with source vertex \(u\), then we solve this problem as well.
Moreover, all known algorithms for this problem have the same worst-case asymptotic running time as the best SSSP problem algorithms (â“).
</p>

<p>
<b>All-piars shortest-paths problem</b>: Find a shortest path from \(u\) to \(v\) for every pair of vertices \(u\) and \(v\). Although we can solve this problem by running a single-source algorithm once from each vertex, we usually can solve it faster (as there are many repeated calculations in this algorithm).
</p>
</div>
</div>

<div id="outline-container-orgf2a6b44" class="outline-5">
<h5 id="orgf2a6b44"><span class="section-number-5">6.6.1.2.</span> Summary of the four problems</h5>
<div class="outline-text-5" id="text-6-6-1-2">
<p>
Using databse cardinality:
</p>
<ul class="org-ul">
<li>\(1:1\): One vertex to one vertex.</li>
<li>\(1:many\): One vertex to multiple vertices.
<ul class="org-ul">
<li>$src:many: base/example problem the algorithm works with.</li>
</ul></li>
<li>\(many:1\): Multiple vertices to one vertex.
<ul class="org-ul">
<li>$many:dest: can be solved by inverting directions of edges and starting from \(dest\) to \(many\).</li>
</ul></li>
<li>\(many:many\): Every vertex to every vertex.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org305e7c0" class="outline-4">
<h4 id="org305e7c0"><span class="section-number-4">6.6.2.</span> Optimal substructure of a shortest path</h4>
<div class="outline-text-4" id="text-6-6-2">
<p>
Shortest paths algorithms typically rely on the property that a shortest path between two vertices contains other shortest paths within it. This property calls for <a href="#orgaab4c60">4.2</a> and Greedy method.
</p>

<p>
Dijkstra's algorithm is a greedy algorithm, and the Floyd-Warshall algorithm, which finds shortest paths in \(many:many\) vertices, is a dynamic-programming algorithm.
</p>
</div>
</div>

<div id="outline-container-org610bc3b" class="outline-4">
<h4 id="org610bc3b"><span class="section-number-4">6.6.3.</span> Negative-weight edges</h4>
<div class="outline-text-4" id="text-6-6-3">
<p>
A graph \(G=(V, E)\) can contain negative-weighted edges \(E_{nw}\) but and be well defined, given that:
for any vertex pair \((u,v)\), if \(w(u, v)<0, w(v, u) > 0\), then \(w(u,v)+w(v, u)\ge 0\). This prevents a <b>negative-weight cycle</b>.
</p>

<div class="org-src-container">
<pre class="src src-ditaa">
Non-negative (+6-3)
+----+ 5   +----+ +6  +----+
|src |----&gt;|5   |----&gt;|11  |
|    |     |    |&lt;----|    |
+----+     +----+ -3  +----+
     
Negative (+6-7)
+----+ 5   +----+ +6  +----+
|src |----&gt;|-inf|----&gt;|-inf|
|    |     |    |&lt;----|    |
+----+     +----+ -7  +----+
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf74c8c7" class="outline-3">
<h3 id="orgf74c8c7"><span class="section-number-3">6.7.</span> Data structure</h3>
<div class="outline-text-3" id="text-6-7">
<p>
<b>Dynamic sets</b>: sets that can grow, shrink, or otherwise change over time.
<b>Dictionary</b>: a dynamic set that supports <code>insert</code>, <code>delete</code>, and <code>test</code> (membership)
</p>

<table id="org8de85be">
<caption class="t-above"><span class="table-number">Table 4:</span> Operations on dynamic sets</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Category</td>
<td class="org-left">Operation</td>
</tr>

<tr>
<td class="org-left">Query</td>
<td class="org-left">search()</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org9602e01" class="outline-4">
<h4 id="org9602e01"><span class="section-number-4">6.7.1.</span> Stacks and queues</h4>
<div class="outline-text-4" id="text-6-7-1">
<table id="org2d896ce">
<caption class="t-above"><span class="table-number">Table 5:</span> Data structures based on list/array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">data structure</th>
<th scope="col" class="org-left">policy</th>
<th scope="col" class="org-left">example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Queue</td>
<td class="org-left">first in, first out</td>
<td class="org-left">real life queue</td>
</tr>

<tr>
<td class="org-left">Stack</td>
<td class="org-left">last in, first out</td>
<td class="org-left">recursive call stack</td>
</tr>

<tr>
<td class="org-left">Priority queue</td>
<td class="org-left">whatever in, min/max key out</td>
<td class="org-left">Triage</td>
</tr>
</tbody>
</table>

<p>
Stack operations (all \(O(1)\)):
</p>
<ul class="org-ul">
<li><code>push(element)</code></li>
<li><code>pop()</code></li>
<li><code>stack_empty()</code></li>
</ul>
<p>
Queue operations (all \(O(1)\)):
</p>
<ul class="org-ul">
<li><code>enqueue(element)</code></li>
<li><code>dequeue()</code></li>
</ul>
</div>
</div>


<div id="outline-container-org70acd79" class="outline-4">
<h4 id="org70acd79"><span class="section-number-4">6.7.2.</span> Linked lists</h4>
<div class="outline-text-4" id="text-6-7-2">
<p>
Three types of linked lists:
</p>
<ul class="org-ul">
<li>singly linked list</li>
<li>doubly linked list</li>
<li>circular list</li>
</ul>

<p>
The following content concerns unsorted Doubly Linked List.
</p>
</div>
</div>

<div id="outline-container-org8efa769" class="outline-4">
<h4 id="org8efa769"><span class="section-number-4">6.7.3.</span> Hash tables</h4>
<div class="outline-text-4" id="text-6-7-3">
<p>
<i>Addressing</i>: Putting one item to a place according to some rule.
</p>

<p>
Direct-address tables: associate keys with indexes in an array of size <code>U</code>, when the number of possible keys \(U\) is small. \(O(1)\) for searching in worst-case scenario.
</p>

<p>
When \(U\) is large, creating an array/table \(T\) of size <code>U</code> may be immpractical.
In addition, the number of keys <b>actually stored</b> may be so small relative to \(U\) that most of the space allocated to the table \(T\) will be wasted.
</p>

<p>
Thus we come up with another idea (Hash Table) to save storage and maintain \(O(1)\) search time in average-case scenario.
</p>

<p>
With hash tables, we now cannot use an element's key to store it because its key might be larger than the length of the hash table. To solve this problem, we use a <b>hash function</b> \(h\) to compute the slot/position in the table \(T\) from key \(k\). \(h\) maps the universe \(U\) of keys into the slots of a <b>hash table</b> \(T[0\ldots m-1]\): \(h:U\rightarrow \{0,1,\ldots,m-1\}\) and \(m\) is usually much less than \(|U|\).
</p>

<p>
We also say that an element with key \(k\) hashes to slot \(h(k)\), and that \(h(k)\) is the <b>hash value</b> of key \(k\). If two keys somehow hash to the same slot, this is called a <b>collision</b>.
</p>

<p>
To minimise or <i>even</i> avoid collision, we make \(h\) appear to be "random", making its output as dispersed as possible.
</p>

<p>
There are two ways to deal with collision: chaining and open addressing.
Chaining: make every slot in the table \(T\) a linked list (doubly linked list makes deletion faster).
</p>

<p>
In a nutshell:
</p>
<ol class="org-ol">
<li>We want to store some objects in such a way that it's fast for us to get to them later via some key.</li>
<li>We then just use an array to store the objects, each is placed in the array using their key as the index, and one can use a key to find the corresponding object in the array. This is called <b>open addressing</b>.</li>
<li>As the number of potential objects grows, it requires more storage. However, most of the time, we only want a subset of the objects to be readily available because those are what we use anyway.</li>
<li>Therefore, there is really no need to store all possible objects.</li>
<li>Then we decide to use a smaller array to store the objects.</li>
<li>Because the key of an object is no longer also an index in the smaller array (the key might be larger than the length of the array), it is logical to develop a <b>function</b> to map the key to an index of the array.</li>
<li>The function is properly named <b>hash function</b>.</li>
<li>The array is then called a <b>hash table</b>.</li>
<li>The story does not end here. Because there are more objects than the number of places available to store them in the array (hash table), it is possible that two elements will be put in the same position (two different keys end up with the same index through the hash function). Pigeon hold theorem.
<ol class="org-ol">
<li>To solve this, we have <b>chaining</b> and <b>open addressing</b></li>
<li>Chaining links all elements that ended up in the same index so the 1-d array now becomes 2-d.
<ol class="org-ol">
<li>Because the linking of the elements at one index can be infinite (as long as the memory is sufficient), the hash table can store infinite objects, but the time spent on retrieving one object also increases until it becomes asymptotically the same as directly searching through all objects.</li>
</ol></li>
<li>Open addressing tries to find the next available index if the current index is already taken.
<ol class="org-ol">
<li>This means that the table can fill up and no more insertion can be made.</li>
</ol></li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org127f7b6" class="outline-4">
<h4 id="org127f7b6"><span class="section-number-4">6.7.4.</span> Priority queue</h4>
<div class="outline-text-4" id="text-6-7-4">
<p>
We use <a href="#org1bf8164">Heap</a> to implement it.
</p>

<p>
A <b>priority queue</b> is a data structure for maintaining a set \(S\) of elements,
each with an associated value called a \(key\) (priority). A <b>max-priority queue</b> supports the 
following operations:
</p>
<ul class="org-ul">
<li>\(insert(S, x)\) inserts the element \(x\) into the set \(S\), i.e. \(S=S\cup \{x\}\), \(O(\lg n)\)</li>
<li>\(maximum(S)\) returns the element of \(S\) with the largest \(key\), \(O(1)\)</li>
<li>\(extract\_max(S)\) removes and returns the element of \(S\) with the largest \(key\), \(O(\lg n)\)</li>
<li>\(increase\_key(S, x, k)\) increases the value of element \(x\text{'s}\) \(key\) to the new value \(k\), which is assumed to be at least as large as the current \(key\), \(O(\lg n)\)</li>
</ul>

<p>
Similarly, a <b>min-priority queue</b> supports:
</p>
<ul class="org-ul">
<li>\(insert(S, x)\) inserts the element \(x\) into the set \(S\), i.e. \(S=S\cup \{x\}\)</li>
<li>\(minimum(S)\) returns the element of \(S\) with the smallest \(key\)</li>
<li>\(extract\_min(S)\) removes and returns the element of \(S\) with the smallest \(key\)</li>
<li>\(decrease\_key(S, x, k)\) decreases the value of element \(x\text{'s}\) \(key\) to the new value \(k\), which is assumed to be at least as small as the current \(key\)</li>
</ul>

<p>
Max-priority queue can be used to schedule jobs on a shared computer.
Min-priority queue can be used in an event-driven simulator.
</p>
</div>

<div id="outline-container-org8dc6dfa" class="outline-5">
<h5 id="org8dc6dfa"><span class="section-number-5">6.7.4.1.</span> Implementation of max-priority queue</h5>
<div class="outline-text-5" id="text-6-7-4-1">
<p>
Based on the pseudo-code on CLRS.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 114: </span>max-priority queue</label><pre class="src src-python" id="orga1a0c1f"><span class="org-keyword">class</span> <span class="org-type">max_priority_queue</span>:

    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, nums: List[<span class="org-builtin">int</span>]):
        <span class="org-keyword">self</span>.q = max_heapify(nums, 0, <span class="org-builtin">len</span>(nums)-1)

    <span class="org-keyword">def</span> <span class="org-function-name">heap_max</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.q[0]

    <span class="org-keyword">def</span> <span class="org-function-name">heap_extract_max</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.q) &lt; 1:
            <span class="org-keyword">raise</span> <span class="org-type">Exception</span>
        <span class="org-variable-name">m</span> = <span class="org-keyword">self</span>.q[0]
        <span class="org-keyword">self</span>.q[0] = <span class="org-keyword">self</span>.q[<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.q)-1]
        <span class="org-keyword">self</span>.max_heapify(<span class="org-keyword">self</span>.q, 1, <span class="org-keyword">self</span>.q[0]-1)

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">max_heapify</span>(arr, i, heap_size):
        <span class="org-keyword">pass</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf54f621" class="outline-2">
<h2 id="orgf54f621"><span class="section-number-2">7.</span> Clock table</h2>
<div class="outline-text-2" id="text-7">
<table>
<caption class="t-above"><span class="table-number">Table 6:</span> Clock summary at <span class="timestamp-wrapper"><span class="timestamp">[2020-05-07 Thu 09:54]</span></span></caption>

<colgroup>
<col  class="org-left">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Headline</th>
<th scope="col" class="org-right">Time</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>Total time</b></td>
<td class="org-right"><b>1d 15:49</b></td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Problems</td>
<td class="org-right">23:22</td>
</tr>

<tr>
<td class="org-left">Algorithms</td>
<td class="org-right">0:54</td>
</tr>

<tr>
<td class="org-left">Techniques</td>
<td class="org-right">0:20</td>
</tr>

<tr>
<td class="org-left">CLRS Notes &amp; Yufei Tao lecture notes</td>
<td class="org-right">11:47</td>
</tr>

<tr>
<td class="org-left">Exporting</td>
<td class="org-right">0:38</td>
</tr>

<tr>
<td class="org-left">Fix up</td>
<td class="org-right">2:48</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga496f61" class="outline-2">
<h2 id="orga496f61"><span class="section-number-2">8.</span> Appendix</h2>
<div class="outline-text-2" id="text-8">
<div id="list-of-listings">
<h2>List of Listings</h2>
<div id="text-list-of-listings">
<ul>
<li><a href="#orga02f155"><span class="listing-number">Listing 1:</span> imports for typing</a></li>
<li><a href="#orgf83cedd"><span class="listing-number">Listing 2:</span> 1313 Decompress Run-length encoded list my solution</a></li>
<li><a href="#org0f6543e"><span class="listing-number">Listing 3:</span> 1313 Decompress Run-length encoded list leetcode solution</a></li>
<li><a href="#orgb419c46"><span class="listing-number">Listing 4:</span> concatenate lists</a></li>
<li><a href="#org3d52ae9"><span class="listing-number">Listing 5:</span> 1295 Find numbers with even number of digits my solution</a></li>
<li><a href="#orge4c148c"><span class="listing-number">Listing 6:</span> 1295 Find numbers with even number of digits leetcode solution</a></li>
<li><a href="#org459899f"><span class="listing-number">Listing 7:</span> 1365 How many numbers are smaller than the current number my solution</a></li>
<li><a href="#org3292690"><span class="listing-number">Listing 8:</span> 1365 How many numbers are smaller than the current number leetcode solution</a></li>
<li><a href="#org0cb9e9a"><span class="listing-number">Listing 9:</span> 1409 Queries on a permutation with key my solution</a></li>
<li><a href="#org3ce47f9"><span class="listing-number">Listing 10:</span> 1409 Queries on a permutation with key discussion solution</a></li>
<li><a href="#orgf19e8ac"><span class="listing-number">Listing 11:</span> 1329 Sort the matrix diagonally my solution</a></li>
<li><a href="#orgc15bac8"><span class="listing-number">Listing 12:</span> 1329 Sort the matrix diagonally leetcode solution</a></li>
<li><a href="#orgd47e22e"><span class="listing-number">Listing 13:</span> 1329 Sort the matrix diagonally 2 my solution</a></li>
<li><a href="#org50a513d"><span class="listing-number">Listing 14:</span> 1329 Sort the matrix diagonally 2 leetcode solution</a></li>
<li><a href="#orgc404ef3"><span class="listing-number">Listing 15:</span> 1395 Count number of teams my solution</a></li>
<li><a href="#orgdb91360"><span class="listing-number">Listing 16:</span> 1395 Count number of teams efficient solution</a></li>
<li><a href="#orgf05d9fe"><span class="listing-number">Listing 17:</span> 1395 Count number of teams general solution</a></li>
<li><a href="#org8a4a48a"><span class="listing-number">Listing 18:</span> 442 Find all duplicates in an array my solution</a></li>
<li><a href="#orgbef37fa"><span class="listing-number">Listing 19:</span> 442 Find all duplicates in an array leetcode solution</a></li>
<li><a href="#org4f39e99"><span class="listing-number">Listing 20:</span> 78 Subsets my solution</a></li>
<li><a href="#org02476e1"><span class="listing-number">Listing 21:</span> 78 Subsets leetcode solution</a></li>
<li><a href="#org587c0d9"><span class="listing-number">Listing 22:</span> 48 Rotate image my solution</a></li>
<li><a href="#orge3ca249"><span class="listing-number">Listing 23:</span> 48 Rotate image leetcode solution</a></li>
<li><a href="#orgac48993"><span class="listing-number">Listing 24:</span> 48 rotate image sample</a></li>
<li><a href="#orge18eda6"><span class="listing-number">Listing 25:</span> 72 Edit distance my solution</a></li>
<li><a href="#org8558d83"><span class="listing-number">Listing 26:</span> 72 Edit distance leetcode solution</a></li>
<li><a href="#org94bc125"><span class="listing-number">Listing 27:</span> 121 Best time to buy and sell stock my solution</a></li>
<li><a href="#orgdcf1006"><span class="listing-number">Listing 28:</span> 121 Best time to buy and sell stock leetcode solution</a></li>
<li><a href="#org2fae78a"><span class="listing-number">Listing 29:</span> 121 Best time to buy and sell stock dp solution</a></li>
<li><a href="#orgc05ff89"><span class="listing-number">Listing 30:</span> 53 Maximum subarray my solution</a></li>
<li><a href="#org5e089af"><span class="listing-number">Listing 31:</span> 53 Maximum subarray leetcode solution</a></li>
<li><a href="#org315cd12"><span class="listing-number">Listing 32:</span> 53 Maximum subarray my solution O(1) space</a></li>
<li><a href="#org37c95f0"><span class="listing-number">Listing 33:</span> 70 Climbming stairs my solution</a></li>
<li><a href="#org2e3519e"><span class="listing-number">Listing 34:</span> 70 Climbming stairs leetcode solution</a></li>
<li><a href="#org3a444bd"><span class="listing-number">Listing 35:</span> 746 Min cost climbing stairs my solution</a></li>
<li><a href="#org2bf5269"><span class="listing-number">Listing 36:</span> 746 Min cost climbing stairs leetcode solution</a></li>
<li><a href="#orgc25172d"><span class="listing-number">Listing 37:</span> 746 Min cost climbing stairs my solution improved</a></li>
<li><a href="#org7820380"><span class="listing-number">Listing 38:</span> 703 Kth largest element in a stream my solution</a></li>
<li><a href="#org35942a9"><span class="listing-number">Listing 39:</span> 703 Kth largest element in a stream my solution-results</a></li>
<li><a href="#org7a827d9"><span class="listing-number">Listing 40:</span> 703 Kth largest element in a stream leetcode solution</a></li>
<li><a href="#org86e4ff4"><span class="listing-number">Listing 41:</span> 703 Kth largest element in a stream leetcode solution-results</a></li>
<li><a href="#orgd56b0ac"><span class="listing-number">Listing 42:</span> 703 Kth largest element in a stream leetcode solution improved</a></li>
<li><a href="#org08da740"><span class="listing-number">Listing 43:</span> 215 Kth largest element in an array my solution</a></li>
<li><a href="#org24b164c"><span class="listing-number">Listing 44:</span> 215 Kth largest element in an array my solution-results</a></li>
<li><a href="#org6ce9505"><span class="listing-number">Listing 45:</span> quickselect implementation</a></li>
<li><span class="listing-number">Listing 46:</span> quickselect implementation-results</li>
<li><a href="#orgddb6b22"><span class="listing-number">Listing 47:</span> 215 Kth largest element in an array leetcode solution</a></li>
<li><a href="#orgc10a7b0"><span class="listing-number">Listing 48:</span> 215 Kth largest element in an array leetcode solution-results</a></li>
<li><a href="#orgc9cdd31"><span class="listing-number">Listing 49:</span> 973 K closest points to origin my solution</a></li>
<li><a href="#orgcd5c796"><span class="listing-number">Listing 50:</span> 973 K closest points to origin my solution-results</a></li>
<li><a href="#org27b13c8"><span class="listing-number">Listing 51:</span> 973 K closest points to origin leetcode solution</a></li>
<li><a href="#org3eac1ad"><span class="listing-number">Listing 52:</span> 973 K closest points to origin leetcode solution-results</a></li>
<li><a href="#org5fdeb40"><span class="listing-number">Listing 53:</span> 347 Top K frequent elements my solution</a></li>
<li><a href="#org1731115"><span class="listing-number">Listing 54:</span> 347 Top K frequent elements my solution-results</a></li>
<li><a href="#org962ebb4"><span class="listing-number">Listing 55:</span> 347 Top K frequent elements leetcode solution</a></li>
<li><a href="#org48433d4"><span class="listing-number">Listing 56:</span> 347 Top K frequent elements leetcode solution-results</a></li>
<li><a href="#org2238c8e"><span class="listing-number">Listing 57:</span> most<sub>common</sub></a></li>
<li><a href="#org7987479"><span class="listing-number">Listing 58:</span> 355 Desin twitter my solution</a></li>
<li><a href="#org3f06a8e"><span class="listing-number">Listing 59:</span> 355 Desin twitter my solution-results</a></li>
<li><a href="#org48768a8"><span class="listing-number">Listing 60:</span> 355 Desin twitter leetcode solution</a></li>
<li><a href="#orgf000ac5"><span class="listing-number">Listing 61:</span> 355 Desin twitter leetcode solution-results</a></li>
<li><a href="#org67f5b5c"><span class="listing-number">Listing 62:</span> 778 Swim in rising water my solution</a></li>
<li><a href="#org8783949"><span class="listing-number">Listing 63:</span> 778 Swim in rising water my solution-results</a></li>
<li><a href="#org55e4274"><span class="listing-number">Listing 64:</span> 778 Swim in rising water my solution - 2</a></li>
<li><a href="#orgea2dc69"><span class="listing-number">Listing 65:</span> 778 Swim in rising water my solution - 3</a></li>
<li><a href="#orgfa3ecdf"><span class="listing-number">Listing 66:</span> 778 Swim in rising water my solution - 4</a></li>
<li><a href="#orgc3ed5f4"><span class="listing-number">Listing 67:</span> 778 Swim in rising water leetcode solution</a></li>
<li><a href="#org1b6cf3f"><span class="listing-number">Listing 68:</span> 778 Swim in rising water leetcode solution-results</a></li>
<li><a href="#org06cd365"><span class="listing-number">Listing 69:</span> 1022 Sum of root to leaf binary numbers my solution</a></li>
<li><a href="#orga576f74"><span class="listing-number">Listing 70:</span> 1022 Sum of root to leaf binary numbers my solution-results</a></li>
<li><a href="#orgc32c44a"><span class="listing-number">Listing 71:</span> 1022 Sum of root to leaf binary numbers leetcode solution</a></li>
<li><a href="#org87e582e"><span class="listing-number">Listing 72:</span> 1022 Sum of root to leaf binary numbers leetcode solution-results</a></li>
<li><a href="#org5bc5569"><span class="listing-number">Listing 73:</span> 1207 Unique number of occurrences my solution</a></li>
<li><a href="#org1e88eb8"><span class="listing-number">Listing 74:</span> 1207 Unique number of occurrences my solution-results</a></li>
<li><a href="#org7ca1b77"><span class="listing-number">Listing 75:</span> 1207 Unique number of occurrences leetcode solution</a></li>
<li><a href="#org8c81779"><span class="listing-number">Listing 76:</span> 1207 Unique number of occurrences leetcode solution-results</a></li>
<li><a href="#orgf4c82b8"><span class="listing-number">Listing 77:</span> 706 Design HashMap my solution</a></li>
<li><a href="#org8ac422a"><span class="listing-number">Listing 78:</span> 706 Design HashMap my solution-results</a></li>
<li><a href="#org795a740"><span class="listing-number">Listing 79:</span> 706 Design HashMap leetcode solution</a></li>
<li><a href="#org3ecc8e7"><span class="listing-number">Listing 80:</span> 706 Design HashMap leetcode solution-results</a></li>
<li><a href="#orge609487"><span class="listing-number">Listing 81:</span> 208 Implementing Trie my solution</a></li>
<li><a href="#org3d32912"><span class="listing-number">Listing 82:</span> 208 Implementing Trie my solution-results</a></li>
<li><a href="#org793ea7e"><span class="listing-number">Listing 83:</span> 208 Implementing Trie leetcode solution</a></li>
<li><a href="#orgaafbeba"><span class="listing-number">Listing 84:</span> 208 Implementing Trie leetcode solution-results</a></li>
<li><a href="#orgb695135"><span class="listing-number">Listing 85:</span> 1038 Binary Search Tree to Greater Sum Tree my solution</a></li>
<li><a href="#orgc890f67"><span class="listing-number">Listing 86:</span> 1038 Binary Search Tree to Greater Sum Tree my solution-results</a></li>
<li><a href="#org58de6fe"><span class="listing-number">Listing 87:</span> 1038 Binary Search Tree to Greater Sum Tree leetcode solution</a></li>
<li><a href="#org1718cf4"><span class="listing-number">Listing 88:</span> 1038 Binary Search Tree to Greater Sum Tree leetcode solution-results</a></li>
<li><a href="#orgfeea9de"><span class="listing-number">Listing 89:</span> 21 Merge Two Sorted Lists my solution</a></li>
<li><a href="#orgf004ed4"><span class="listing-number">Listing 90:</span> 21 Merge Two Sorted Lists my solution-results</a></li>
<li><a href="#orgbd26a14"><span class="listing-number">Listing 91:</span> 21 Merge Two Sorted Lists leetcode solution</a></li>
<li><a href="#org9b51d63"><span class="listing-number">Listing 92:</span> 21 Merge Two Sorted Lists leetcode solution-results</a></li>
<li><a href="#org0af70dd"><span class="listing-number">Listing 93:</span> 20 Valid Parentheses my solution</a></li>
<li><a href="#orgd6a255e"><span class="listing-number">Listing 94:</span> 20 Valid Parentheses my solution-results</a></li>
<li><a href="#org5167bfd"><span class="listing-number">Listing 95:</span> 20 Valid Parentheses leetcode solution</a></li>
<li><a href="#org10fcc8f"><span class="listing-number">Listing 96:</span> 20 Valid Parentheses leetcode solution-results</a></li>
<li><a href="#orgb80f57c"><span class="listing-number">Listing 97:</span> Insertion sort</a></li>
<li><a href="#orgd961cae"><span class="listing-number">Listing 98:</span> dynamic programming - edit distance</a></li>
<li><a href="#orge4a9ed5"><span class="listing-number">Listing 99:</span> dynamic programming - edit distance improved</a></li>
<li><a href="#orga97c8b3"><span class="listing-number">Listing 100:</span> bitmask</a></li>
<li><a href="#orgee0b6a8"><span class="listing-number">Listing 101:</span> A 3-node construct that <code>max-heapify</code> works on</a></li>
<li><a href="#orgd907f83"><span class="listing-number">Listing 102:</span> max-heapify</a></li>
<li><span class="listing-number">Listing 103:</span> max-heapify-results</li>
<li><a href="#orgb858248"><span class="listing-number">Listing 104:</span> build-max-heap</a></li>
<li><a href="#orgd98f975"><span class="listing-number">Listing 105:</span> heapsort</a></li>
<li><a href="#orgb4097f4"><span class="listing-number">Listing 106:</span> quicksort</a></li>
<li><span class="listing-number">Listing 107:</span> quicksort-results</li>
<li><a href="#orgc9187cd"><span class="listing-number">Listing 108:</span> partitioning the array</a></li>
<li><a href="#org130444a"><span class="listing-number">Listing 109:</span> Quickselect python implementation</a></li>
<li><a href="#org8820dda"><span class="listing-number">Listing 110:</span> selection worst case linear</a></li>
<li><a href="#org7245a4f"><span class="listing-number">Listing 111:</span> cutting rod recursive top-down implementation</a></li>
<li><a href="#orge2af453"><span class="listing-number">Listing 112:</span> top-bottom dynamic programming meoization</a></li>
<li><a href="#orgfb8e8d8"><span class="listing-number">Listing 113:</span> bottom-up dynamic programming approach</a></li>
<li><a href="#orga1a0c1f"><span class="listing-number">Listing 114:</span> max-priority queue</a></li>
</ul>
</div>
</div>
<div id="list-of-tables">
<h2>List of Tables</h2>
<div id="text-list-of-tables">
<ul>
<li><a href="#org69d87ee"><span class="table-number">Table 1:</span> Sorting time complexity</a></li>
<li><a href="#org2eebde9"><span class="table-number">Table 2:</span> Sort algorithms and cache performance</a></li>
<li><a href="#org9c4b648"><span class="table-number">Table 3:</span> Quicksort running time</a></li>
<li><a href="#org8de85be"><span class="table-number">Table 4:</span> Operations on dynamic sets</a></li>
<li><a href="#org2d896ce"><span class="table-number">Table 5:</span> Data structures based on list/array</a></li>
<li><span class="table-number">Table 6:</span> Clock summary at <span class="timestamp-wrapper"><span class="timestamp">[2020-05-07 Thu 09:54]</span></span></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Yi Wang</p>
<p class="date">Created: 2022-01-19 Wed 22:22</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
